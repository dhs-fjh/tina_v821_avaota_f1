#!/bin/bash
#
# pack/pack
# (c) Copyright 2013
# Allwinner Technology Co., Ltd. <www.allwinnertech.com>
# James Deng <csjamesdeng@allwinnertech.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

############################ Notice #####################################
# a. Some config files priority is as follows:
#    - xxx_${platform}.{cfg|fex} > xxx.{cfg|fex}
#    - ${chip}/${board}/*.{cfg|fex} > ${chip}/default/*.{cfg|fex}
#    - ${chip}/default/*.cfg > ${LICHEE_COMMON_CONFIG_DIR}/imagecfg/*.cfg
#    - ${chip}/default/*.fex > ${LICHEE_COMMON_CONFIG_DIR}/partition/*.fex
#  e.g. sun8iw7p1/configs/perf/image_linux.cfg > sun8iw7p1/configs/default/image_linux.cfg
#       > ${LICHEE_COMMON_CONFIG_DIR}/imagecfg/image_linux.cfg > sun8iw7p1/configs/perf/image.cfg
#       > sun8iw7p1/configs/default/image.cfg > ${LICHEE_COMMON_CONFIG_DIR}/imagecfg/image.cfg
#
# b. Support Nor storages rule:
#    - Need to create sys_partition_nor.fex or sys_partition_nor_${platform}.fex
#    - Add "{filename = "full_img.fex",     maintype = "12345678", \
#      subtype = "FULLIMG_00000000",}" to image[_${platform}].cfg
#
# c. Switch uart port
#    - Need to add your chip configs into ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_pin
#    - Call pack with 'debug' parameters

#if you want to debug pack, set vlaue to 1. use pause func in the place where you want to stop
enable_pause=0

function get_char()
{
	SAVEDSTTY=`stty -g`
	stty -echo
	stty cbreak
	dd if=/dev/tty bs=1 count=1 2> /dev/null
	stty -raw
	stty echo
	stty $SAVEDSTTY
}

function pause()
{
	if [ "x$1" != "x" ] ;then
		echo "$1"
	fi
	if [ $enable_pause -eq 1 ] ; then
		echo "Press any key to continue!"
		char=`get_char`
	fi
}

function pack_error()
{
	echo -e "\033[47;31mERROR: $*\033[0m"
}

function pack_warn()
{
	echo -e "\033[47;34mWARN: $*\033[0m"
}

function pack_info()
{
	echo -e "\033[47;30mINFO: $*\033[0m"
}

localpath=$(cd $(dirname $0) && pwd)
. $localpath/shflags

# define option, format:
#   'long option' 'default value' 'help message' 'short option'
DEFINE_string 'chip' '' 'chip to build, e.g. sun7i' 'c'
DEFINE_string 'ic' '' 'ic to build, e.g. a50' 'i'
DEFINE_string 'addition' '' 'additional config files, e.g. xx.fex' 'a'
DEFINE_string 'platform' '' 'platform to build, e.g. linux, android' 'p'
DEFINE_string 'platform_version' '' 'platform version to build' 'V'
DEFINE_string 'board' '' 'board to build, e.g. evb' 'b'
DEFINE_string 'kernel' '' 'kernel to build, e.g. linux-3.4, linux-3.10' 'k'
DEFINE_string 'debug_mode' 'uart0' 'config debug mode, e.g. uart0, card0' 'd'
DEFINE_string 'signture' 'none' 'pack boot signture to do secure boot' 's'
DEFINE_string 'secure' 'none' 'pack secure boot with -v arg' 'v'
DEFINE_string 'mode' 'normal' 'pack dump firmware' 'm'
DEFINE_string 'function' 'android' 'pack private firmware' 'f'
DEFINE_string 'vsp' '' 'pack firmware for vsp' 't'
DEFINE_string 'programmer' '' 'creat programmer img or not' 'w'
DEFINE_string 'key_path' '' 'the path of keys' 'P'
DEFINE_string 'nor' 'none' 'pack nor image' 'n'
DEFINE_boolean 'verity' false 'if enable dm-verity' ''
DEFINE_boolean 'signfel' false 'if enable fel signing' ''
DEFINE_string 'boot_path' '' 'the path of gki boot.img' 'B'
DEFINE_string 'output_resources' '' 'only output resources to pack-out' ''
DEFINE_string 'from_resources' '' 'pack from resources path' ''

# parse the command-line
FLAGS "$@" || exit $?
eval set -- "${FLAGS_ARGV}"

PACK_CHIP=${FLAGS_chip}
PACK_IC=${FLAGS_ic}
PACK_PLATFORM=${FLAGS_platform}
PACK_PLATFORM_VERSION=${FLAGS_platform_version}
PACK_BOARD=${FLAGS_board}
PACK_KERN=${FLAGS_kernel}
PACK_DEBUG=${FLAGS_debug_mode}
PACK_SIG=${FLAGS_signture}
PACK_SECURE=${FLAGS_secure}
PACK_MODE=${FLAGS_mode}
PACK_FUNC=${FLAGS_function}
PACK_VSP=${FLAGS_vsp}
PACK_PROGRAMMER=${FLAGS_programmer}
PACK_NOR=${FLAGS_nor}
PACK_PRODUCT=${FLAGS_product}
PACK_VERITY=${FLAGS_verity}
PACK_SIGNFEL=${FLAGS_signfel}
PACK_ADD_FILES=(${FLAGS_addition})
PACK_KEY_PATH=${FLAGS_key_path}
PACK_FLASHMAP_ENABLE=""

CFG_TOP_DIR=$(cd $localpath/../ && pwd)
CFG_PLAT_OUT=$CFG_TOP_DIR/out/$PACK_IC/$PACK_BOARD/$PACK_PLATFORM
CFG_KEY_DIR=$CFG_TOP_DIR/out/$PACK_IC/common/keys

if [ ! -z "${PACK_KEY_PATH}" ]; then
    CFG_KEY_DIR=${PACK_KEY_PATH}
fi
pack_info "${CFG_KEY_DIR}"

if [ ! -d ${CFG_PLAT_OUT} ] || \
   [ ! -f $CFG_PLAT_OUT/.buildconfig ]; then
	pack_error "config & build lichee before you pack"
	exit 1
fi

source $CFG_PLAT_OUT/.buildconfig
if [ x"${LICHEE_PACK_NOR_AND_DEFAULT_FLASH}" != x"" ]; then
	if [ x"${PACK_NOR}" = x"default" ]; then
		echo "source $CFG_PLAT_OUT/.buildconfig_default"
		source $CFG_PLAT_OUT/.buildconfig_default
		#default flash should define here, not in BoardCfonig.mk
		LICHEE_PACK_NOR_AND_DEFAULT_FLASH="y"
	else
		echo "nor use $CFG_PLAT_OUT/.buildconfig"
	fi
fi

if [ -z "${PACK_KERN}" ]; then
	pack_info "No kernel param, parse it from .buildconfig"
	PACK_KERN=$LICHEE_KERN_VER
	if [ -z "${PACK_KERN}" ]; then
		pack_error "Failed to parse kernel param from .buildconfig"
		exit 1
	fi
fi

PACK_TYPE=""
case "x${PACK_PLATFORM}" in
	"xandroid")
		PACK_TYPE="android"
		;;
	"xdragonboard")
		PACK_TYPE="dragonboard"
		;;
	"xdragonabts")
		PACK_TYPE="dragonabts"
		;;
	"xbsp"|"xsata"|"xbuildroot"|"xopenwrt"|"xdebian")
		PACK_TYPE="linux"
		;;
	*)
		pack_error "Unsupport PACK_PLATFORM: ${PACK_PLATFORM}"
		exit 1
		;;
esac

export PATH=${LICHEE_TOOLS_DIR}/pack/pctools/linux/mod_update:${LICHEE_TOOLS_DIR}/pack/pctools/linux/openssl:${LICHEE_TOOLS_DIR}/pack/pctools/linux/eDragonEx:${LICHEE_TOOLS_DIR}/pack/pctools/linux/fsbuild200:${LICHEE_TOOLS_DIR}/pack/pctools/linux/android:$PATH
export LD_LIBRARY_PATH=${LICHEE_TOOLS_DIR}/pack/pctools/linux/softhsm/lib/:$LD_LIBRARY_PATH

tools_file_list=(
${LICHEE_COMMON_CONFIG_DIR}/tools/split_xxxx.fex
${LICHEE_CHIP_CONFIG_DIR}/tools/split_xxxx.fex
${LICHEE_COMMON_CONFIG_DIR}/tools/usbtool_test.fex
${LICHEE_COMMON_CONFIG_DIR}/tools/usbtool_crash.fex
${LICHEE_CHIP_CONFIG_DIR}/tools/usbtool_test.fex
${LICHEE_COMMON_CONFIG_DIR}/tools/cardscript.fex
${LICHEE_COMMON_CONFIG_DIR}/tools/cardscript_secure.fex
${LICHEE_CHIP_CONFIG_DIR}/tools/cardscript.fex
${LICHEE_CHIP_CONFIG_DIR}/tools/cardscript_secure.fex
${LICHEE_COMMON_CONFIG_DIR}/tools/cardtool.fex
${LICHEE_CHIP_CONFIG_DIR}/tools/cardtool.fex
${LICHEE_COMMON_CONFIG_DIR}/tools/usbtool.fex
${LICHEE_CHIP_CONFIG_DIR}/tools/usbtool.fex
${LICHEE_COMMON_CONFIG_DIR}/tools/usbtool_crash.fex
${LICHEE_CHIP_CONFIG_DIR}/tools/usbtool_crash.fex
${LICHEE_COMMON_CONFIG_DIR}/tools/aultls32.fex
${LICHEE_CHIP_CONFIG_DIR}/tools/aultls32.fex
${LICHEE_COMMON_CONFIG_DIR}/tools/aultools.fex
${LICHEE_CHIP_CONFIG_DIR}/tools/aultools.fex
)

configs_file_list=(
${LICHEE_COMMON_CONFIG_DIR}/toc/toc1.fex
${LICHEE_COMMON_CONFIG_DIR}/toc/toc0.fex
${LICHEE_COMMON_CONFIG_DIR}/toc/toc0_sdcard.fex
${LICHEE_COMMON_CONFIG_DIR}/toc/toc0_nand.fex
${LICHEE_COMMON_CONFIG_DIR}/toc/toc0_ufs.fex
${LICHEE_COMMON_CONFIG_DIR}/toc/toc0_ft.fex
${LICHEE_COMMON_CONFIG_DIR}/toc/boot_package.fex
${LICHEE_COMMON_CONFIG_DIR}/hdcp/esm.fex
${LICHEE_COMMON_CONFIG_DIR}/dtb/sunxi.fex
${LICHEE_COMMON_CONFIG_DIR}/imagecfg/*.cfg
${LICHEE_COMMON_CONFIG_DIR}/partition/sys_partition_dump.fex
${LICHEE_COMMON_CONFIG_DIR}/partition/sys_partition_private.fex
${LICHEE_COMMON_CONFIG_DIR}/version/version_base.mk
${LICHEE_CHIP_CONFIG_DIR}/configs/default/*
${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD}/*.fex
${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD}/boot_package*.cfg
${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD}/${LICHEE_KERN_VER}/*.cfg
${LICHEE_CHIP_CONFIG_DIR}/configs/default/version_base.mk
${LICHEE_CHIP_CONFIG_DIR}/dtbo/*
${LICHEE_BOARD_CONFIG_DIR}/dtbo/*
${LICHEE_CHIP_CONFIG_DIR}/${BIN_PATH}/ft_${PACK_CHIP}.bin
${LICHEE_COMMON_CONFIG_DIR}/sign_config/dragon_toc_ft.cfg
${LICHEE_CHIP_CONFIG_DIR}/configs/default/dragon_toc_ft.cfg
${LICHEE_COMMON_CONFIG_DIR}/sign_config/cnf_base.cnf
${LICHEE_PLAT_OUT}/.buildconfig
)

product_configs_file_list=(
${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD}/${PACK_PLATFORM}/*.fex
${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD}/${PACK_PLATFORM}/*.cfg
)

boot_resource_list=(
${LICHEE_CHIP_CONFIG_DIR}/boot-resource/boot-resource:${LICHEE_PACK_OUT_DIR}
${LICHEE_CHIP_CONFIG_DIR}/boot-resource/boot-resource.ini:${LICHEE_PACK_OUT_DIR}
${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD}/*.bmp:${LICHEE_PACK_OUT_DIR}/boot-resource/
${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD}/bootlogo.bmp:${LICHEE_PACK_OUT_DIR}/bootlogo.bmp
${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD}/wavefile/*:${LICHEE_PACK_OUT_DIR}/boot-resource/wavefile/
${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD}/${PACK_TYPE}/*.bmp:${LICHEE_PACK_OUT_DIR}/boot-resource/
${LICHEE_CHIP_CONFIG_DIR}/boot-resource/boot-resource/bat/bempty.bmp:${LICHEE_PACK_OUT_DIR}/bempty.bmp
${LICHEE_CHIP_CONFIG_DIR}/boot-resource/boot-resource/bat/battery_charge.bmp:${LICHEE_PACK_OUT_DIR}/battery_charge.bmp
${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD}/bat0.bmp:${LICHEE_PACK_OUT_DIR}/boot-resource/bat/bat0.bmp
${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD}/battery_charge.bmp:${LICHEE_PACK_OUT_DIR}/boot-resource/bat/battery_charge.bmp
)

boot_file_list=(
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/boot0_nand_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/boot0_nand.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/boot0_sdcard_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/boot0_sdcard.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/boot0_ufs_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/boot0_ufs.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/boot0_${LICHEE_BOOT0_BIN_NAME}_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/boot0_${LICHEE_BOOT0_BIN_NAME}.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/boot0_nandfastboot_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/boot0_nandfastboot_${PACK_CHIP}.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/boot0_spinor_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/boot0_spinor.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/pmboot_nand_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/pmboot_nand.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/pmboot_sdcard_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/pmboot_sdcard.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/pmboot_ufs_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/pmboot_ufs.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/pmboot_${LICHEE_BOOT0_BIN_NAME}_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/pmboot_${LICHEE_BOOT0_BIN_NAME}.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/pmboot_nandfastboot_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/pmboot_nandfastboot_${PACK_CHIP}.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/pmboot_spinor_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/pmboot_spinor.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/fes1_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/fes1.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/fes1_uart_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/fes1_uart.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/u-boot-${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/u-boot.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/u-boot-${LICHEE_EFEX_BIN_NAME}.bin:${LICHEE_PACK_OUT_DIR}/u-boot-efex.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/u-boot-crashdump-${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/u-boot-crash.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/u-boot-crashdump-spinor-${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/u-boot-spinor-crash.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/bl31.bin:${LICHEE_PACK_OUT_DIR}/monitor.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/bl31_${PACK_BOARD}.bin:${LICHEE_PACK_OUT_DIR}/monitor.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/scp.bin:${LICHEE_PACK_OUT_DIR}/scp.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/amp_dsp0.bin:${LICHEE_PACK_OUT_DIR}/amp_dsp0.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/amp_dsp1.bin:${LICHEE_PACK_OUT_DIR}/amp_dsp1.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/amp_rv0.bin:${LICHEE_PACK_OUT_DIR}/amp_rv0.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/video.bin:${LICHEE_PACK_OUT_DIR}/video.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/optee_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/optee.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/optee_${PACK_CHIP}-monitor.bin:${LICHEE_PACK_OUT_DIR}/optee-monitor.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/opensbi_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/opensbi.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/u-boot-spinor-${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/u-boot-spinor.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/u-boot-spinor-secure-${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/u-boot-spinor-secure.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/*.fex:${LICHEE_PACK_OUT_DIR}/
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/*.dtb:${LICHEE_PACK_OUT_DIR}/
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/*.bin:${LICHEE_PACK_OUT_DIR}/
)

boot_file_list_2=(
${LICHEE_PLAT_OUT}/arisc:${LICHEE_PACK_OUT_DIR}/arisc.fex
${LICHEE_PLAT_OUT}/sunxi.dtb:${LICHEE_PACK_OUT_DIR}/sunxi.fex
${LICHEE_PLAT_OUT}/boot0_nand_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/boot0_nand.fex
${LICHEE_PLAT_OUT}/boot0_sdcard_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/boot0_sdcard.fex
${LICHEE_PLAT_OUT}/boot0_${LICHEE_BOOT0_BIN_NAME}_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/boot0_${LICHEE_BOOT0_BIN_NAME}.fex
${LICHEE_PLAT_OUT}/boot0_spinor_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/boot0_spinor.fex
${LICHEE_PLAT_OUT}/pmboot_nand_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/pmboot_nand.fex
${LICHEE_PLAT_OUT}/pmboot_sdcard_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/pmboot_sdcard.fex
${LICHEE_PLAT_OUT}/pmboot_${LICHEE_BOOT0_BIN_NAME}_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/pmboot_${LICHEE_BOOT0_BIN_NAME}.fex
${LICHEE_PLAT_OUT}/pmboot_spinor_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/pmboot_spinor.fex
${LICHEE_PLAT_OUT}/fes1_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/fes1.fex
${LICHEE_PLAT_OUT}/fes1_uart_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/fes1_uart.fex
${LICHEE_PLAT_OUT}/sboot_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/sboot.bin
${LICHEE_PLAT_OUT}/sboot_nor_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/sboot_nor.bin
${LICHEE_PLAT_OUT}/sboot_sdcard_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/sboot_sdcard.bin
${LICHEE_PLAT_OUT}/sboot_nand_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/sboot_nand.bin
${LICHEE_PLAT_OUT}/sboot_ufs_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/sboot_ufs.bin
${LICHEE_PLAT_OUT}/u-boot-${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/u-boot.fex
${LICHEE_PLAT_OUT}/u-boot-${LICHEE_EFEX_BIN_NAME}.bin:${LICHEE_PACK_OUT_DIR}/u-boot-${LICHEE_EFEX_BIN_NAME}.fex
${LICHEE_PLAT_OUT}/u-boot-crashdump-${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/u-boot-crash.fex
${LICHEE_PLAT_OUT}/u-boot-crashdump-spinor-${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/u-boot-spinor-crash.fex
${LICHEE_PLAT_OUT}/scp.bin:${LICHEE_PACK_OUT_DIR}/scp.fex
${LICHEE_PLAT_OUT}/u-boot-spinor-${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/u-boot-spinor.fex
${LICHEE_PLAT_OUT}/u-boot-spinor-secure-${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/u-boot-spinor-secure.fex
${LICHEE_PLAT_OUT}/vmlinux.tar.bz2:${LICHEE_PACK_OUT_DIR}/vmlinux.fex
)

arm_boot_file_secure=(
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/semelis_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/semelis.bin
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/optee_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/optee.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/sboot_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/sboot.bin
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/sboot_nor_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/sboot_nor.bin
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/sboot_sdcard_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/sboot_sdcard.bin
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/sboot_nand_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/sboot_nand.bin
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/sboot_ufs_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/sboot_ufs.bin
${LICHEE_COMMON_CONFIG_DIR}/sign_config/dragon_toc_android.cfg:${LICHEE_PACK_OUT_DIR}/dragon_toc.cfg
${LICHEE_CHIP_CONFIG_DIR}/configs/default/dragon_toc_android.cfg:${LICHEE_PACK_OUT_DIR}/dragon_toc.cfg
)

arm64_boot_file_secure=(
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/optee_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/optee.fex
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/sboot_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/sboot.bin
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/sboot_nor_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/sboot_nor.bin
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/sboot_sdcard_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/sboot_sdcard.bin
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/sboot_nand_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/sboot_nand.bin
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/sboot_ufs_${PACK_CHIP}.bin:${LICHEE_PACK_OUT_DIR}/sboot_ufs.bin
${LICHEE_COMMON_CONFIG_DIR}/sign_config/dragon_toc_a64_android.cfg:${LICHEE_PACK_OUT_DIR}/dragon_toc.cfg
${LICHEE_CHIP_CONFIG_DIR}/configs/default/dragon_toc_android.cfg:${LICHEE_PACK_OUT_DIR}/dragon_toc.cfg
${LICHEE_CHIP_CONFIG_DIR}/\${BIN_PATH}/amp_rv0.bin:${LICHEE_PACK_OUT_DIR}/amp_rv0.fex
)

#
# This function can get the realpath between $SRC and $DST
#
function get_realpath()
{
	local src=$(cd $1; pwd);
	local dst=$(cd $2; pwd);
	local res="./";
	local tmp="$dst"

	while [ "${src##*$tmp}" == "${src}" ]; do
		tmp=${tmp%/*};
		res=$res"../"
	done
	res="$res${src#*$tmp/}"

	printf "%s" $res
}

function show_boards()
{
	printf "\nAll avaiable chips, platforms and boards:\n\n"
	printf "Chip            Board\n"
	for chipdir in $(find chips/ -mindepth 1 -maxdepth 1 -type d) ; do
		chip=`basename ${chipdir}`
		printf "${chip}\n"
		for boarddir in $(find chips/${chip}/configs/${platform} \
			-mindepth 1 -maxdepth 1 -type d) ; do
			board=`basename ${boarddir}`
			printf "                ${board}\n"
		done
	done
	printf "\nFor Usage:\n"
	printf "     $(basename $0) -h\n\n"
}

function uart_switch()
{
	rm -rf ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	touch ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	TX=`awk  '$0~"'$PACK_CHIP'"{print $2}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_pin`
	RX=`awk  '$0~"'$PACK_CHIP'"{print $3}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_pin`
	PORT=`awk  '$0~"'$PACK_CHIP'"{print $4}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_pin`
	MS=`awk  '$0~"'$PACK_CHIP'"{print $5}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_pin`
	CK=`awk  '$0~"'$PACK_CHIP'"{print $6}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_pin`
	DO=`awk  '$0~"'$PACK_CHIP'"{print $7}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_pin`
	DI=`awk  '$0~"'$PACK_CHIP'"{print $8}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_pin`

	BOOT_UART_ST=`awk  '$0~"'$PACK_CHIP'"{print $2}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	BOOT_PORT_ST=`awk  '$0~"'$PACK_CHIP'"{print $3}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	BOOT_TX_ST=`awk  '$0~"'$PACK_CHIP'"{print $4}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	BOOT_RX_ST=`awk  '$0~"'$PACK_CHIP'"{print $5}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	UART0_ST=`awk  '$0~"'$PACK_CHIP'"{print $6}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	UART0_USED_ST=`awk  '$0~"'$PACK_CHIP'"{print $7}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	UART0_PORT_ST=`awk  '$0~"'$PACK_CHIP'"{print $8}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	UART0_TX_ST=`awk  '$0~"'$PACK_CHIP'"{print $9}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	UART0_RX_ST=`awk  '$0~"'$PACK_CHIP'"{print $10}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	UART1_ST=`awk  '$0~"'$PACK_CHIP'"{print $11}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	JTAG_ST=`awk  '$0~"'$PACK_CHIP'"{print $12}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	MS_ST=`awk  '$0~"'$PACK_CHIP'"{print $13}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	CK_ST=`awk  '$0~"'$PACK_CHIP'"{print $14}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	DO_ST=`awk  '$0~"'$PACK_CHIP'"{print $15}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	DI_ST=`awk  '$0~"'$PACK_CHIP'"{print $16}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	MMC0_ST=`awk  '$0~"'$PACK_CHIP'"{print $17}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`
	MMC0_USED_ST=`awk  '$0~"'$PACK_CHIP'"{print $18}' ${LICHEE_COMMON_CONFIG_DIR}/debug/card_debug_string`

	if [ -z "$TX" ] || [ -z "$BOOT_UART_ST" ]; then
		pack_error "$FUNCNAME: $PACK_CHIP not configured in card_debug_pin/card_debug_string!"
		exit 1
	fi

	echo '$0!~";" && $0~"'$BOOT_TX_ST'"{if(C)$0="'$BOOT_TX_ST' = '$TX'"} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	echo '$0!~";" && $0~"'$BOOT_RX_ST'"{if(C)$0="'$BOOT_RX_ST' = '$RX'"} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	echo '$0!~";" && $0~"'$BOOT_PORT_ST'"{if(C)$0="'$BOOT_PORT_ST' = '$PORT'"} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	if [ "`grep "auto_print_used" "${LICHEE_PACK_OUT_DIR}/sys_config.fex" | grep "1"`" ]; then
		echo '$0!~";" && $0~"'$MMC0_USED_ST'"{if(A)$0="'$MMC0_USED_ST' = 1";A=0} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	else
	echo '$0!~";" && $0~"'$MMC0_USED_ST'"{if(A)$0="'$MMC0_USED_ST' = 0";A=0} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	fi
	echo '$0!~";" && $0~"\\['$MMC0_ST'\\]"{A=1}  \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	echo '$0!~";" && $0~"'$UART0_TX_ST'"{if(B)$0="'$UART0_TX_ST' = '$TX'"} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	echo '$0!~";" && $0~"'$UART0_RX_ST'"{if(B)$0="'$UART0_RX_ST' = '$RX'"} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	echo '$0!~";" && $0~"\\['$UART0_ST'\\]"{B=1} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	echo '$0!~";" && $0~"'$UART0_USED_ST'"{if(B)$0="'$UART0_USED_ST' = 1"}  \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	echo '/^'$UART0_PORT_ST'/{next} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	echo '$0!~";" && $0~"\\['$UART1_ST'\\]"{B=0} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	echo '$0!~";" && $0~"\\['$BOOT_UART_ST'\\]"{C=1} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	echo '$0!~";" && $0~"\\['$JTAG_ST'\\]"{C=0} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	echo '$0!~";" && $0~"'$MS_ST'"{$0="'$MS_ST' = '$MS'"} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	echo '$0!~";" && $0~"'$CK_ST'"{$0="'$CK_ST' = '$CK'"} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	echo '$0!~";" && $0~"'$DO_ST'"{$0="'$DO_ST' = '$DO'"} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	echo '$0!~";" && $0~"'$DI_ST'"{$0="'$DI_ST' = '$DI'"} \' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0
	echo '1' >> ${LICHEE_PACK_OUT_DIR}/awk_debug_card0

	if [ "`grep "auto_print_used" "${LICHEE_PACK_OUT_DIR}/sys_config.fex" | grep "1"`" ]; then
		sed -i -e '/^uart0_rx/a\pinctrl-1=' ${LICHEE_PACK_OUT_DIR}/sys_config.fex
		sed -i -e '/^uart0_rx/a\pinctrl-0=' ${LICHEE_PACK_OUT_DIR}/sys_config.fex
	fi

	awk -f ${LICHEE_PACK_OUT_DIR}/awk_debug_card0 ${LICHEE_PACK_OUT_DIR}/sys_config.fex > ${LICHEE_PACK_OUT_DIR}/sys_config_debug.fex
	rm -f ${LICHEE_PACK_OUT_DIR}/sys_config.fex
	mv ${LICHEE_PACK_OUT_DIR}/sys_config_debug.fex ${LICHEE_PACK_OUT_DIR}/sys_config.fex
	echo "uart -> card0"
}

function add_lzma_header()
{
	lzma_file=$1
	original_file=$2
	file_size=$(printf "%.8x\n" `stat -c%s ${lzma_file}`)
	original_file_size=$(printf "%.8x\n" `stat -c%s ${original_file}`)

	bin_str=""

	file_size_len=${#file_size}

	#"LZMA"+size+origin_size
	bin_str="\x4c\x5a\x4d\x41\x${file_size:6:2}\x${file_size:4:2}\x${file_size:2:2}\x${file_size:0:2}"
	bin_str+="\x${original_file_size:6:2}\x${original_file_size:4:2}\x${original_file_size:2:2}\x${original_file_size:0:2}"


	printf "%b" ${bin_str} > tempbin

	cat ${lzma_file} >> tempbin

	mv tempbin "${lzma_file}.head"
}

function partition_size_handle()
{
	echo "handle partition_size"
	local filename=${LICHEE_PACK_OUT_DIR}/sys_partition.fex
	local size
	local number
	local dimension
	local blocks
	local line
	local m
	local index=0
	while read line; do
		let "index++"
		size=$(echo $line | awk -F= '/^[[:space:]]*size[[:space:]]*=/{print $2}' | sed 's|\s\+||g')
		if [ -n "$size" ]; then
			dimension=$(echo $size | sed 's|^[0-9,.]\+||g')
			[ -z "$dimension" ] && continue
			case $dimension in
				B|b)
					m=1
					;;
				K|k)
					m=1024
					;;
				M|m)
					m=1048576
					;;
				G|g)
					m=1073741824
					;;
				*)
					pack_error "ERROR Dimension($dimension)!"
					return 1
					;;
			esac
			number=$(echo $size | sed 's|[a-z,A-Z]*$||g')
			blocks=$(echo "$number * $m / 512" | bc | awk -F. '{print $1}')
			printf "sys_partition.fex: size %6s => %7d Blocks\n" "${number}${dimension}" "${blocks}"
			size="$(echo "$line" | sed "s|=.*$|= $blocks|g")"
			sed -i "${index}s|$line|$size|g" $filename
		fi
	done < $filename
	return 0
}

function do_prepare()
{
	local runinfo=($(lsof 2>/dev/null | awk '$9~"'$LICHEE_TOP_DIR/tools/build/buildserver'"{print $2}'))
	local possible_bin_path="${LICHEE_POSSIBLE_BIN_PATH}"

	if [ ${#runinfo[@]} -lt 2 ]; then
		pack_error "something is incorrect:please <./build.sh config>."
	fi

	if [ -z "${PACK_CHIP}" -o -z "${PACK_TYPE}" -o -z "${PACK_BOARD}" ] ; then
		pack_error "Invalid parameters Chip: ${PACK_CHIP}, \
			Platform: ${PACK_TYPE}, Board: ${PACK_BOARD}"
		show_boards
		exit 1
	fi

	if [ ! -d ${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD} ] ; then
		pack_error "Board's directory \
			\"${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD}\" is not exist."
		show_boards
		exit 1
	fi

	# Cleanup
	if [ "x" != "x${LICHEE_PACK_OUT_DIR}" ]; then
		rm -rf ${LICHEE_PACK_OUT_DIR}
	fi
	mkdir -p ${LICHEE_PACK_OUT_DIR}

	(
		cd $LICHEE_OUT_DIR
		if [ "${LICHEE_PACK_OUT_DIR}" != "$LICHEE_OUT_DIR/pack_out" ]; then
			rm -rf pack_out
			ln -sf ${LICHEE_IC}/${LICHEE_BOARD}/pack_out pack_out
		fi
	)

	[ -e ${LICHEE_CHIP_CONFIG_DIR}/configs/default/pack-prepare ] &&
		source ${LICHEE_CHIP_CONFIG_DIR}/configs/default/pack-prepare

	[ -e ${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD}/pack-prepare ] &&
		source ${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD}/pack-prepare

	printf "copying tools file\n"
	for file in ${tools_file_list[@]} ; do
		cp -f $file ${LICHEE_PACK_OUT_DIR} 2> /dev/null
	done

	if [ "x${PACK_KERN}" = "xlinux-3.4" ]; then
		cp -f ${LICHEE_COMMON_CONFIG_DIR}/tools/cardscript.fex ${LICHEE_PACK_OUT_DIR} 2> /dev/null
	fi

	printf "copying configs file\n"
	for file in ${configs_file_list[@]} ; do
		cp -f $file ${LICHEE_PACK_OUT_DIR} 2> /dev/null
	done

	printf "copying product configs file\n"
	for file in ${product_configs_file_list[@]}; do
		cp -f $file ${LICHEE_PACK_OUT_DIR} 2>/dev/null
	done

	if [ x"${PACK_PLATFORM}" != x"android" ]; then
		printf "linux copying boardt&linux_kernel_version configs file\n"
		local possible_env_path=(
			configs/default
			configs/${LICHEE_BOARD}
			configs/${LICHEE_BOARD}/${LICHEE_KERN_VER}
			configs/${LICHEE_BOARD}/${PACK_PLATFORM}
		)
		local possible_env_list=(
			env.cfg
			env-$(echo ${LICHEE_KERN_VER} | awk -F '-' '{print $2}').cfg
		)
		local copy_env_file=''

		for d in ${possible_env_path[@]}; do
			[ ! -d ${LICHEE_CHIP_CONFIG_DIR}/$d ] && continue
			for file in ${possible_env_list[@]} ; do
				if [ -e "${LICHEE_CHIP_CONFIG_DIR}/$d/$file" ]; then
					copy_env_file=${LICHEE_CHIP_CONFIG_DIR}/$d/$file
				fi
			done
		done
		echo "Use u-boot env file: ${copy_env_file}"
		if [[ ! -f ${copy_env_file} ]]
		then
			echo -e "\e[33mWarning: u-boot env file '${copy_env_file}' not exist! use file in default directory other than '${PACK_BOARD}' directory\e[0m"
		fi

		cp -f ${copy_env_file} ${LICHEE_PACK_OUT_DIR}/env.cfg 2>/dev/null

		cp -f ${LICHEE_CHIP_CONFIG_DIR}/configs/${PACK_BOARD}/${LICHEE_KERN_VER}/sys_* ${LICHEE_PACK_OUT_DIR} 2>/dev/null
	fi

	# If platform config files exist, we will cover the default files
	# For example, mv pack_out/image_linux.cfg pack_out/image.cfg
	if [ ${PACK_PLATFORM} != "android" ]; then
		cp -f ${LICHEE_BOARD_CONFIG_DIR}/${PACK_PLATFORM}/* ${LICHEE_PACK_OUT_DIR} 2> /dev/null
		if [ ${PACK_PLATFORM} = "bsp" -o "x${PACK_PLATFORM}" = "xsata" ] ; then
			find ${LICHEE_PACK_OUT_DIR}/* -type f -a \( -name "*.fex" -o -name "*.cfg" \) -print | \
			sed "s#\(.*\)_linux\(\..*\)#mv -fv & \1\2#e"
		else
			find ${LICHEE_PACK_OUT_DIR}/* -type f -a \( -name "*.fex" -o -name "*.cfg" \) -print | \
			sed "s#\(.*\)_${PACK_PLATFORM}\(\..*\)#mv -fv & \1\2#e"
		fi
	else
		find ${LICHEE_PACK_OUT_DIR}/* -type f -a \( -name "*.fex" -o -name "*.cfg" \) -print | \
			sed "s#\(.*\)_${PACK_TYPE}\(\..*\)#mv -fv & \1\2#e"
	fi

	if [ "x${PACK_MODE}" = "xdump" ] ; then
		cp -vf ${LICHEE_PACK_OUT_DIR}/sys_partition_dump.fex ${LICHEE_PACK_OUT_DIR}/sys_partition.fex
		cp -vf ${LICHEE_PACK_OUT_DIR}/usbtool_test.fex ${LICHEE_PACK_OUT_DIR}/usbtool.fex
	elif [ "x${PACK_FUNC}" = "xprvt" ] ; then
		cp -vf ${LICHEE_PACK_OUT_DIR}/sys_partition_private.fex ${LICHEE_PACK_OUT_DIR}/sys_partition.fex
	fi

	printf "copying boot resource\n"
	for file in ${boot_resource_list[@]} ; do
		cp -rf $(echo $file | sed -e 's/:/ /g') 2>/dev/null
	done

	# openwrt use these logo files
	if [ x"${PACK_PLATFORM}" = x"openwrt" ]; then
		rm -rf ${LICHEE_PACK_OUT_DIR}/boot-resource
		cp -rf $CFG_TOP_DIR/${PACK_PLATFORM}/target/$PACK_IC/$PACK_IC-common/boot-resource/boot-resource ${LICHEE_PACK_OUT_DIR}
		cp -rf $CFG_TOP_DIR/${PACK_PLATFORM}/target/$PACK_IC/$PACK_IC-common/boot-resource/boot-resource.ini ${LICHEE_PACK_OUT_DIR}/boot-resource.ini
	fi

	if [ ! -f ${LICHEE_PACK_OUT_DIR}/bootlogo.bmp ]; then
		cp ${LICHEE_PACK_OUT_DIR}/boot-resource/bootlogo.bmp ${LICHEE_PACK_OUT_DIR}/bootlogo.bmp
	fi

	lzma -k ${LICHEE_PACK_OUT_DIR}/bootlogo.bmp
	lzma -k ${LICHEE_PACK_OUT_DIR}/bempty.bmp
	lzma -k ${LICHEE_PACK_OUT_DIR}/battery_charge.bmp

	if [ -f ${LICHEE_PACK_OUT_DIR}/bootlogo.bmp.lzma ]; then
		add_lzma_header "${LICHEE_PACK_OUT_DIR}/bootlogo.bmp.lzma" "${LICHEE_PACK_OUT_DIR}/bootlogo.bmp"
		(cd ${LICHEE_PACK_OUT_DIR}; ln -sf bootlogo.bmp.lzma.head  bootlogo.fex)
	fi

	if [ -d ${LICHEE_BOARD_CONFIG_DIR}/bin ] ; then
		cp ${LICHEE_BOARD_CONFIG_DIR}/bin/* ${LICHEE_CHIP_CONFIG_DIR}/bin/ -rf
	fi

	printf "copying boot file\n"
	for d in ${possible_bin_path[@]}; do
		[ ! -d ${LICHEE_CHIP_CONFIG_DIR}/$d ] && continue
		BIN_PATH=$d
		for file in ${boot_file_list[@]} ; do
			eval cp -v -f $(echo $file | sed -e 's/:/ /g') 2>/dev/null
		done
	done
	printf "copying boot file 2.0\n"
	for file in ${boot_file_list_2[@]} ; do
		eval cp -v -f $(echo $file | sed -e 's/:/ /g') 2>/dev/null
	done
	if [[ ${LICHEE_BOARD} == *fastboot*spinand* ]] ; then
		mv -v ${LICHEE_PACK_OUT_DIR}/boot0_nandfastboot_${PACK_CHIP}.fex ${LICHEE_PACK_OUT_DIR}/boot0_nand.fex
	fi

	if ! [ -z ${LICHEE_BOOT0_BIN_NAME} ]; then
		# nand fastboot
		cp -v -f ${LICHEE_PACK_OUT_DIR}/boot0_${LICHEE_BOOT0_BIN_NAME}.fex ${LICHEE_PACK_OUT_DIR}/boot0_nand.fex

		if [[ ${LICHEE_FLASH} == default ]] ; then
			mv -v ${LICHEE_PACK_OUT_DIR}/boot0_${LICHEE_BOOT0_BIN_NAME}.fex ${LICHEE_PACK_OUT_DIR}/boot0_sdcard.fex
		elif [[ ${LICHEE_FLASH} == nor ]] ; then
			mv -v ${LICHEE_PACK_OUT_DIR}/boot0_${LICHEE_BOOT0_BIN_NAME}.fex ${LICHEE_PACK_OUT_DIR}/boot0_spinor.fex
		else
			echo "invalid LICHEE_FLASH, default choose sdcard!"
			mv -v ${LICHEE_PACK_OUT_DIR}/boot0_${LICHEE_BOOT0_BIN_NAME}.fex ${LICHEE_PACK_OUT_DIR}/boot0_sdcard.fex
		fi
		if [ -f ${LICHEE_PACK_OUT_DIR}/pmboot_${LICHEE_BOOT0_BIN_NAME}.fex ]; then
			# nand fastboot
			echo "LICHEE_FLASH is ${LICHEE_FLASH}, LICHEE_BOOT0_BIN_NAME is ${LICHEE_BOOT0_BIN_NAME}!"
			cp -v -f ${LICHEE_PACK_OUT_DIR}/pmboot_${LICHEE_BOOT0_BIN_NAME}.fex ${LICHEE_PACK_OUT_DIR}/pmboot_nand.fex

			if [[ ${LICHEE_FLASH} == default ]] ; then
				mv -v ${LICHEE_PACK_OUT_DIR}/pmboot_${LICHEE_BOOT0_BIN_NAME}.fex ${LICHEE_PACK_OUT_DIR}/pmboot_sdcard.fex
			elif [[ ${LICHEE_FLASH} == nor ]] ; then
				mv -v ${LICHEE_PACK_OUT_DIR}/pmboot_${LICHEE_BOOT0_BIN_NAME}.fex ${LICHEE_PACK_OUT_DIR}/pmboot_spinor.fex
			else
				echo "invalid LICHEE_FLASH, default choose sdcard!"
				mv -v ${LICHEE_PACK_OUT_DIR}/pmboot_${LICHEE_BOOT0_BIN_NAME}.fex ${LICHEE_PACK_OUT_DIR}/pmboot_sdcard.fex
			fi
		fi
	fi

	[ -z "${BIN_PATH}" ] &&
	pack_error "No BIN_PATH found!" && exit 1

	printf "copying $LICHEE_ARCH secure boot file\n"
	for d in ${possible_bin_path[@]}; do
		[ ! -d ${LICHEE_CHIP_CONFIG_DIR}/$d ] && continue
		BIN_PATH=$d
		for file in $(eval echo '$'"{${LICHEE_ARCH}_boot_file_secure[@]}"); do
			eval cp -f $(echo $file | sed -e 's/:/ /g') 2>/dev/null
		done
	done

	# If platform config use
	if [ -f ${LICHEE_CHIP_CONFIG_DIR}/tools/plat_config.sh ] ; then
		${LICHEE_CHIP_CONFIG_DIR}/tools/plat_config.sh
	fi

	if [ "x${PACK_NOR}" = "xnor" ] ; then
		cp -vf ${LICHEE_PACK_OUT_DIR}/image_nor.cfg ${LICHEE_PACK_OUT_DIR}/image.cfg
		cp -vf ${LICHEE_PACK_OUT_DIR}/sboot_nor.bin ${LICHEE_PACK_OUT_DIR}/sboot.bin
		cp -vf ${LICHEE_PACK_OUT_DIR}/dragon_toc_nor.cfg ${LICHEE_PACK_OUT_DIR}/dragon_toc.cfg
	fi

	if [ "x${PACK_VSP}" = "xvsp" ] ; then
		printf "change usb_port_type to device...\n"
		printf "disable usb_serial_unique...\n"
		printf "change usb_serial_number to ${PACK_TYPE}_android...\n"
		sed -i 's/^usb_port_type.*/usb_port_type = 0/g' ${LICHEE_PACK_OUT_DIR}/sys_config.fex
		sed -i 's/^usb_serial_unique.*/usb_serial_unique = 0/g' ${LICHEE_PACK_OUT_DIR}/sys_config.fex
		sed -i 's/^usb_serial_number.*/usb_serial_number = "'"${PACK_CHIP}"'_android"/g' ${LICHEE_PACK_OUT_DIR}/sys_config.fex
	fi

	printf "copying additional files\n"
	for file in ${PACK_ADD_FILES[@]}; do
		cp -vf $(echo $file | sed -e 's/:/ /g') 2>/dev/null
	done

	if [ "x${PACK_PLATFORM}" == "xandroid" ] && [ "x$TARGET_BUILD_VARIANT" == "xuser" ]; then
		pack_info "change kernel loglevel to 3 for android user build"
		sed -i 's|^\s*loglevel=[0-9]\s*$|loglevel=3|g' ${LICHEE_PACK_OUT_DIR}/env.cfg
		if [ "${ENABLE_VENDOR_ADB}" == "true" ]; then
			pack_info "enable vendor adb for android user build"
			sed -i 's|^init_rc=.*$|init_rc=/vendor/etc/init/hw/init.aw.rc|g' ${LICHEE_PACK_OUT_DIR}/env.cfg
		fi
	fi

	if [ "x${PACK_PROGRAMMER}" = "xprogrammer" ]; then
		printf "add programmer img info target in sys config\n"
		sed -i -e '/^\[target\]/a\programmer=1' ${LICHEE_PACK_OUT_DIR}/sys_config.fex
	fi

	sed -i 's/\\boot-resource/\/boot-resource/g' ${LICHEE_PACK_OUT_DIR}/boot-resource.ini
	sed -i 's/\\\\/\//g' ${LICHEE_PACK_OUT_DIR}/image.cfg
	sed -i 's/^imagename/;imagename/g' ${LICHEE_PACK_OUT_DIR}/image.cfg

	prepare_mixed_androiddragonboard
	[ $? -ne 0 ] && exit 1

	partition_size_handle
	[ $? -ne 0 ] && exit 1

	if [ x"${PACK_PLATFORM}" = x"openwrt" ]; then
		cd ${LICHEE_PACK_OUT_DIR}/
		echo "vmlinux" > ${LICHEE_PACK_OUT_DIR}/vmlinux.fex
		if [ "x${PACK_NOR}" = "xnor" ] ; then
			make_user_res sys_partition_nor.fex
			make_app_res sys_partition_nor.fex
			make_data_res sys_partition_nor.fex
		else
			make_user_res sys_partition.fex
			make_app_res sys_partition.fex
			make_data_res sys_partition.fex
		fi
		cd - > /dev/null
	fi
}

function img_to_programmer()
{
	local out_img=$1
	local in_img=$2

	cd ${LICHEE_PACK_OUT_DIR}/

	if [ "x${PACK_SECURE}" = "xsecure" ]; then
		if [ -f toc0_sdcard.fex ] ; then
			programmer_img toc0_sdcard.fex toc1.fex ${out_img} > /dev/null
		elif [ -f toc0_nand.fex ] ; then
			programmer_img toc0_nand.fex toc1.fex ${out_img} > /dev/null
		else
			programmer_img toc0.fex toc1.fex ${out_img} > /dev/null
		fi
	else
		programmer_img boot0_sdcard.fex boot_package.fex ${out_img} > /dev/null
	fi

	if [ -f sunxi_gpt.fex ] ; then
		#create_img for sunxi_gpt.fex
		programmer_img sys_partition.bin sunxi_mbr.fex ${out_img} ${in_img} sunxi_gpt.fex > /dev/null
	else
		#create_img for sunxi_mbr.fex
		programmer_img sys_partition.bin sunxi_mbr.fex ${out_img} ${in_img} > /dev/null
	fi

}

function uboot_ini_to_dts()
{
	local TARGET_UBOOT
	local PLATFORM_ADDR
	local SOC_ADDR
	local DTC_FLAGS=""

	if [ x${LICHEE_BRANDY_UBOOT_VER} == x2023 ]; then
		pack_info "skip split fdt"
		return
	fi

	if [ "x${PACK_NOR}" == "xnor" ]; then
		TARGET_UBOOT=${LICHEE_PACK_OUT_DIR}/u-boot-spinor.fex
	else
		TARGET_UBOOT=${LICHEE_PACK_OUT_DIR}/u-boot.fex
	fi
	sunxi_ubootools split ${TARGET_UBOOT} > /dev/null
	if [ $? -ne 0 ]
	then
		pack_warn "split uboot and fdt failed!!"
		return
	fi

	[ "$(readlink -f .)" != "$(readlink -f ${LICHEE_PACK_OUT_DIR})" ] && {
		mv temp_fdt.dtb  ${LICHEE_PACK_OUT_DIR}
		mv temp_ubootnodtb.bin  ${LICHEE_PACK_OUT_DIR}
	}

	# to dts
	$DTC_COMPILER ${DTC_FLAGS} -I dtb -O dts -o ${LICHEE_PACK_OUT_DIR}/.uboot.dtb.dts.tmp ${LICHEE_PACK_OUT_DIR}/temp_fdt.dtb  2>/dev/null

	PLATFORM_ADDR=`grep -Po "(?<=platform@)(\w+)(?=\s*{)" ${LICHEE_PACK_OUT_DIR}/.uboot.dtb.dts.tmp | head -1`
	SOC_ADDR=`grep -Po "(?<=soc@)(\w+)(?=\s*{)" ${LICHEE_PACK_OUT_DIR}/.uboot.dtb.dts.tmp | head -1`

	if [ "x${PACK_TYPE}" = "xdragonboard" -o "x${PACK_TYPE}" = "xdragonabts" ] ; then
		cat <<- EOF >> ${LICHEE_PACK_OUT_DIR}/.uboot.dtb.dts.tmp
		/{
			soc@${SOC_ADDR} {
				platform@${PLATFORM_ADDR} {
				dragonboard_test = <1>;
				};
			};
		};
		EOF
	fi

	# to dtb
	$DTC_COMPILER ${DTC_FLAGS} -I dts -O dtb -o ${LICHEE_PACK_OUT_DIR}/temp_fdt.dtb ${LICHEE_PACK_OUT_DIR}/.uboot.dtb.dts.tmp  2>/dev/null

	# get update_to_ubootfdt value from sysconfig
	sunxi_ubootools subkey_value sys_config.bin sunxi_ubootools update_to_ubootfdt > /dev/null
	if [ $? -eq 1 ]; then
		echo "uboot ini to dts"
		$DTC_COMPILER -p 2048 ${DTC_FLAGS} -@ -O dtb -o ${LICHEE_PACK_OUT_DIR}/new_fdt.dtb	\
			-b 0			\
			-i ${LICHEE_PACK_OUT_DIR}	\
			-F $DTC_INI_FILE \
			-d ${LICHEE_PACK_OUT_DIR}/temp_fdt.dtb ${LICHEE_PACK_OUT_DIR}/.uboot.dtb.dts.tmp 2>/dev/null
	else
		mv ${LICHEE_PACK_OUT_DIR}/temp_fdt.dtb  ${LICHEE_PACK_OUT_DIR}/new_fdt.dtb
	fi

	sunxi_ubootools merge ${LICHEE_PACK_OUT_DIR}/temp_ubootnodtb.bin ${LICHEE_PACK_OUT_DIR}/new_fdt.dtb > /dev/null
	cp -vf ${LICHEE_PACK_OUT_DIR}/temp_ubootnodtb.bin ${TARGET_UBOOT}
	# .uboot.dts is the last dts of uboot
	$DTC_COMPILER ${DTC_FLAGS} -I dtb -O dts -o ${LICHEE_PACK_OUT_DIR}/.uboot.dts ${LICHEE_PACK_OUT_DIR}/new_fdt.dtb 2>/dev/null
}

function do_ini_to_dts()
{
	cd ${LICHEE_PACK_OUT_DIR}/

	maybe_busybox unix2dos sys_config.fex
	script  sys_config.fex > /dev/null

	local DTC_SRC_PATH=${LICHEE_PLAT_OUT}
	local DTC_COMPILER=${LICHEE_PLAT_OUT}/dtc
	local DTC_FLAGS=""

	uboot_ini_to_dts

	if [ "x${PACK_KERN}" == "xlinux-3.4" \
			-o "x${PACK_KERN}" == "xlinux-3.10" \
			-o "x${PACK_KERN}" == "xlinux-4.4" \
			-o "x${PACK_KERN}" == "xlinux-5.4" \
			-o "x${PACK_KERN}" == "xlinux-5.4-ansc" \
			-o "x${PACK_KERN}" == "xlinux-5.10" \
			-o "x${PACK_KERN}" == "xlinux-5.10-rt" \
			-o "x${PACK_KERN}" == "xlinux-5.10-origin" \
			-o "x${PACK_KERN}" == "xlinux-5.15" \
			-o "x${PACK_KERN}" == "xlinux-5.15-origin" ] || [[  ${PACK_KERN/linux-} > 5.15 ]]; then
		# For debug: sunxi.dtb -> .sunxi.dts
		$DTC_COMPILER ${DTC_FLAGS} -I dtb -O dts -o ${LICHEE_PLAT_OUT}/.sunxi.dts ${LICHEE_PLAT_OUT}/sunxi.dtb 2>/dev/null
		return
	fi

	local dtc_file_list=(
		.board.dtb.d.dtc.tmp:.board.dtb.dts.tmp
		.${PACK_CHIP}-${PACK_BOARD}.dtb.d.dtc.tmp:.${PACK_CHIP}-${PACK_BOARD}.dtb.dts.tmp
		.${PACK_CHIP}-${LICHEE_BUSSINESS}.dtb.d.dtc.tmp:.${PACK_CHIP}-${LICHEE_BUSSINESS}.dtb.dts.tmp
		.${PACK_CHIP}-soc.dtb.d.dtc.tmp:.${PACK_CHIP}-soc.dtb.dts.tmp)

	local DTC_INI_FILE_BASE=${LICHEE_PACK_OUT_DIR}/sys_config.fex
	local DTC_INI_FILE=${LICHEE_PACK_OUT_DIR}/sys_config_fix.fex

	cp $DTC_INI_FILE_BASE $DTC_INI_FILE
	sed -i "s/\(\[dram\)_para\(\]\)/\1\2/g" $DTC_INI_FILE
	sed -i "s/\(\[nand[0-9]\)_para\(\]\)/\1\2/g" $DTC_INI_FILE

	if [ ! -f $DTC_COMPILER ]; then
		pack_error "Script_to_dts: Can not find dtc compiler.\n"
		exit 1
	fi

	local DTC_DEP_FILE DTC_SRC_FILE
	for e in ${dtc_file_list[@]}; do
		DTC_DEP_FILE=$DTC_SRC_PATH/${e/:*}
		if [ -f $DTC_DEP_FILE ]; then
			DTC_SRC_FILE=$DTC_SRC_PATH/${e#*:}
			break
		fi
	done

	echo "sunxi_dtb create"
	$DTC_COMPILER -p 2048 ${DTC_FLAGS} -@ -O dtb -o ${LICHEE_PLAT_OUT}/sunxi.dtb	\
		-b 0			\
		-i $DTC_SRC_PATH	\
		-F $DTC_INI_FILE	\
		-d $DTC_DEP_FILE $DTC_SRC_FILE 2>/dev/null

	if [ $? -ne 0 ]; then
		pack_error "Conver script to dts failed"
		exit 1
	fi

	#restore the orignal dtsi
	if [ "x${PACK_TYPE}" = "xdragonboard" \
		-o "x${PACK_TYPE}" = "xdragonmat" ]; then
		local DTS_PATH=${LICHEE_KERN_DIR}/arch/${LICHEE_ARCH}/boot/dts
		[ "x${LICHEE_ARCH}" = "xarm64" ] && DTS_PATH=${LICHEE_KERN_DIR}/arch/${LICHEE_ARCH}/boot/dts/sunxi
		if [ -f ${DTS_PATH}/${PACK_CHIP}_bak.dtsi ];then
			rm -f ${DTS_PATH}/${PACK_CHIP}.dtsi
			mv  ${DTS_PATH}/${PACK_CHIP}_bak.dtsi  ${DTS_PATH}/${PACK_CHIP}.dtsi
		fi
	fi

	printf "Conver script to dts ok.\n"

	# It'is used for debug dtb
	$DTC_COMPILER ${DTC_FLAGS} -I dtb -O dts -o ${LICHEE_PLAT_OUT}/.sunxi.dts ${LICHEE_PLAT_OUT}/sunxi.dtb 2>/dev/null

	return
}

function maybe_busybox()
{
	if [ "x$(which busybox)" == "x" ]; then
		pack_error "Tool busybox does not exist!"
		exit 1
	fi

	busybox $@ || $@
}

function generate_env_use_mkenvimage()
{
	echo "--mkenvimage create redundant env data!--"
	echo "--redundant $1 data size ${LICHEE_REDUNDANT_ENV_SIZE}---"
	mv $1 .env.cfg
	sed 's/#.*//' .env.cfg > $1
	# mkenvimage -r -p 0x00 -s ${LICHEE_REDUNDANT_ENV_SIZE} -o env.fex env_burn.cfg
	if [ "x${LICHEE_ONE_ENV_SIZE}" != "x" ]; then
		echo "use mkenvimage to make one env, size:${LICHEE_ONE_ENV_SIZE}"
		mkenvimage -p 0x00 -s ${LICHEE_ONE_ENV_SIZE} -o $2 $1
	else
		mkenvimage -r -p 0x00 -s $3 -o $2 $1
	fi
}

function generate_env_for_uboot()
{
	# u_boot_env_gen env_nor.cfg env_nor.fex >/dev/null
	u_boot_env_gen $1 $2 >/dev/null
}

function do_common()
{
	cd ${LICHEE_PACK_OUT_DIR}/

	echo $(date -d "$ts" +"%Y-%m-%d %H:%M:%S") > ${LICHEE_PACK_OUT_DIR}/sunxi_version.fex

	# Here, we can switch uart to card or normal
	if [ "x${PACK_DEBUG}" = "xcard0" -a "x${PACK_MODE}" != "xdump" \
		-a "x${PACK_FUNC}" != "xprvt" ] ; then \
		uart_switch
	else
		sed -i -e '/^auto_print_used/s\1\0\' ${LICHEE_PACK_OUT_DIR}/sys_config.fex
	fi

	if [ "x${PACK_SECURE}" = "xsecure" ]; then
		printf "add burn_secure_mode in target in sys config\n"
		sed -i -e '/^\[target\]/a\burn_secure_mode=1' ${LICHEE_PACK_OUT_DIR}/sys_config.fex
		sed -i -e '/^\[platform\]/a\secure_without_OS=0' ${LICHEE_PACK_OUT_DIR}/sys_config.fex
		if [ -f ${LICHEE_PACK_OUT_DIR}/optee-monitor.fex ]; then
			rm -f ${LICHEE_PACK_OUT_DIR}/optee-monitor.fex
		fi
	else
		sed -i '/^burn_secure_mod/d' ${LICHEE_PACK_OUT_DIR}/sys_config.fex
		sed -i '/^secure_without_OS/d' ${LICHEE_PACK_OUT_DIR}/sys_config.fex
		if [ -f ${LICHEE_PACK_OUT_DIR}/optee-monitor.fex ]; then
			mv -v ${LICHEE_PACK_OUT_DIR}/optee-monitor.fex ${LICHEE_PACK_OUT_DIR}/optee.fex
		fi
	fi

	if [ ! -f board_config.fex ]; then
		echo "[empty]" > board_config.fex
	fi

	maybe_busybox unix2dos sys_config.fex
	maybe_busybox unix2dos board_config.fex
	script  sys_config.fex > /dev/null
	cp -f   sys_config.bin config.fex
	script  board_config.fex > /dev/null
	cp -f board_config.bin board.fex

	maybe_busybox unix2dos sys_partition.fex
	script  sys_partition.fex > /dev/null


	if [ "x${PACK_TYPE}" = "xdragonboard" ] ; then
		maybe_busybox dos2unix test_config.fex
		cp test_config.fex boot-resource/
		maybe_busybox unix2dos test_config.fex
		script test_config.fex > /dev/null
		cp test_config.bin boot-resource/
	fi

	if [ "x${PACK_TYPE}" = "xdragonabts" ] ; then
		maybe_busybox dos2unix test_config.fex
		cp test_config.fex boot-resource/
		maybe_busybox unix2dos test_config.fex
		script test_config.fex > /dev/null
		cp test_config.bin boot-resource/
	fi
	# Those files for SpiNor. We will try to find sys_partition_nor.fex
	if [ "x${PACK_NOR}" = "xnor" ] ; then

		if [ ! -f sys_partition_nor.fex ];  then
			echo "sys partition for nor not exist"
			exit 1
		fi

		if [ ! -f ${LICHEE_CHIP_CONFIG_DIR}/tools/arisc_config_parse.sh ]; then
			if [ -f "scp.fex" ]; then
				echo "update scp"
				update_scp scp.fex sunxi.fex >/dev/null
			fi
		fi

		# Here, will create sys_partition_nor.bin
		maybe_busybox unix2dos sys_partition_nor.fex
		script  sys_partition_nor.fex > /dev/null
		update_boot0 boot0_spinor.fex   sys_config.bin SPINOR_FLASH > /dev/null
		update_chip boot0_spinor.fex   > /dev/null
		update_fes1  fes1.fex           sys_config.bin > /dev/null
		if [ -f pmboot_spinor.fex ]; then
			echo "update pmboot_spinor.fex"
			update_boot0 pmboot_spinor.fex sys_config.bin SPINOR_FLASH > /dev/null
		fi

		if [ "x${PACK_KERN}" = "xlinux-3.4" ] ; then
			update_uboot -merge u-boot-spinor.fex  sys_config.bin > /dev/null
		else
			update_uboot -no_merge u-boot-spinor.fex  sys_config.bin > /dev/null
			update_uboot -no_merge u-boot-spinor-secure.fex  sys_config.bin > /dev/null
			[ -f u-boot-efex.fex ] && {
				update_uboot -no_merge u-boot-efex.fex  sys_config.bin > /dev/null
			}
		fi

		while read line
		do
			compress_name=(`echo $line | awk '($1 !~ ";" && ($2 ~ "lzma" || $2 ~ "lz4" || $2 ~ "gz")) {print $2}'`)
			source_name=(`echo $compress_name | cut -d \.  -f 1,2 | cut -d \  -f 2`)
			compress_type=(`echo $compress_name | cut -d \.  -f 3 | cut -d \  -f 2`)
			[ -z "$compress_name" ] && continue
			case $compress_type in
			"gz")
				[ -f $source_name ] && gzip -c $source_name > $compress_name || echo "no exist $source_name"
				echo "compress name: $compress_name"
				;;
			"lzma")
				[ -f $source_name ] && lzma -k $source_name || echo "no exist $source_name"
				mv $source_name.lzma $compress_name >/dev/null 2<&1
				echo "compress name: $compress_name"
				;;
			"lz4")
				[ -f $source_name ] && lz4 -f $source_name $compress_name || echo "no exist $source_name"
				echo "compress name: $compress_name"
				;;
			*)
				echo "no match compress type"
				;;
			esac
			echo "compress type: $compress_type"
		done < boot_package_nor.cfg

		if [ -f boot_package_nor.cfg ]; then
			mv u-boot-spinor-crash.fex u-boot-crash.fex
			echo "pack boot package"
			maybe_busybox unix2dos boot_package.cfg
			dragonsecboot -pack boot_package_nor.cfg
			cp boot_package.fex boot_package_nor.fex
		fi
		# Ugly, but I don't have a better way to change it.
		# We just set env's downloadfile name to env_nor.cfg in sys_partition_nor.fex
		# And if env_nor.cfg is not exist, we should copy one.
		if [ ! -f env_nor.cfg ]; then
			cp -f env.cfg env_nor.cfg >/dev/null 2<&1
		fi

		#card sprite
		if [ -f "boot0_sdcard.fex" ]; then
			update_boot0 boot0_sdcard.fex   sys_config.bin SDMMC_CARD > /dev/null
			update_chip boot0_sdcard.fex > /dev/null
		fi

		# Fixup boot mode for SPINor, just can bootm
		sed -i '/^boot_normal/s#\<boota\>#bootm#g' env_nor.cfg

		echo 1:LICHEE_REDUNDANT_ENV_SIZE:$LICHEE_REDUNDANT_ENV_SIZE
		if [ "x${LICHEE_REDUNDANT_ENV_SIZE}" != "x" ]  || [ "x${LICHEE_ONE_ENV_SIZE}" != "x" ]; then
			generate_env_use_mkenvimage env_nor.cfg env_nor.fex ${LICHEE_REDUNDANT_ENV_SIZE}
		else
			generate_env_for_uboot env_nor.cfg env_nor.fex
		fi
	else
		update_boot0 boot0_nand.fex     sys_config.bin NAND > /dev/null
		update_boot0 boot0_sdcard.fex   sys_config.bin SDMMC_CARD > /dev/null
		update_boot0 boot0_ufs.fex   sys_config.bin UFS > /dev/null
		update_chip boot0_nand.fex >/dev/null
		update_chip boot0_sdcard.fex >/dev/null
		update_chip boot0_ufs.fex >/dev/null

		if [ -f pmboot_nand.fex ]; then
			echo "update pmboot_nand.fex"
			update_boot0 pmboot_nand.fex sys_config.bin NAND > /dev/null
		fi
		if [ -f pmboot_sdcard.fex ]; then
			echo "update pmboot_sdcard.fex"
			update_boot0 pmboot_sdcard.fex sys_config.bin SDMMC_CARD > /dev/null
		fi
	fi

	if [ ! -f "u-boot-crash.fex" ]; then
		touch "u-boot-crash.fex"
		echo "ensure u-boot-crash.fex is not empty" > u-boot-crash.fex
	fi

	if [ -f "sunxi.fex" ]; then
		update_dtb sunxi.fex 4096
	fi

	if [ ! -f ${LICHEE_CHIP_CONFIG_DIR}/tools/arisc_config_parse.sh ]; then
		if [ -f "scp.fex" ]; then
			echo "update scp"
			update_scp scp.fex sunxi.fex >/dev/null
		fi
	fi

	if [ -f "optee.fex" ]; then
		echo "update optee"
		update_optee optee.fex sunxi.fex >/dev/null
	fi

	# Those files for Nand or Card
	if [ "x${PACK_KERN}" = "xlinux-3.4" ] ; then
		update_uboot -merge u-boot.fex sys_config.bin > /dev/null
	else
		update_uboot -no_merge u-boot.fex sys_config.bin > /dev/null
		[ -f u-boot-nodtb.fex ] && {
			update_uboot -no_merge u-boot-nodtb.fex sys_config.bin > /dev/null
		}
		[ -f u-boot-efex.fex ] && {
			update_uboot -no_merge u-boot-efex.fex  sys_config.bin > /dev/null
		}
	fi

	if [ -f "fes1_uart.fex" ]; then
		update_fes1  fes1_uart.fex           sys_config.bin > /dev/null
	fi

	update_fes1  fes1.fex           sys_config.bin > /dev/null
	if [ -f ${LICHEE_TOOLS_DIR}/pack/pctools/linux/mod_update/update_sboot ];then
		update_sboot sboot.bin  sys_config.bin  > /dev/null
		if [ $? -ne 0 ]
		then
			pack_error "update sboot run error"
			exit 1
		fi
	fi
	fsbuild      boot-resource.ini  split_xxxx.fex > /dev/null

	if [ -f boot_package_uartburn.cfg ]; then
		dragonsecboot -pack boot_package_uartburn.cfg
		if [ $? -ne 0 ]
		then
			pack_error "dragon pack boot_package_uartburn run error"
			exit 1
		fi
		mv boot_package.fex boot_package_uartburn.fex
	fi

	if [ -f boot_package.cfg ]; then
		if [ "x$LINUX_DTBO_FILE" = "x" ]; then
			echo "do not set LINUX_DTBO_FILE"
			line_num=`sed -n -e "/default.dtbo/=" boot_package.cfg`
			if [ "x$line_num" != "x" ]; then
				sed -i "$line_num s/^/;/g" boot_package.cfg
			fi
		else
			if [ -f $LINUX_DTBO_FILE ]
			then
				sed -i "s/default.dtbo/$LINUX_DTBO_FILE/g" boot_package.cfg
			else
				line_num=`sed -n -e "/default.dtbo/=" boot_package.cfg`
				if [ "x$line_num" != "x" ]; then
					sed -i "$line_num s/^/;/g" boot_package.cfg
				fi
			fi
		fi

			echo "pack boot package"
			maybe_busybox unix2dos boot_package.cfg
			dragonsecboot -pack boot_package.cfg

		if [ $? -ne 0 ]
		then
			pack_error "dragon pack run error"
			exit 1
		fi
	fi

	echo 2:LICHEE_REDUNDANT_ENV_SIZE:$LICHEE_REDUNDANT_ENV_SIZE
	if [ "x${PACK_FUNC}" = "xprvt" ] ; then
		if [ "x${LICHEE_REDUNDANT_ENV_SIZE}" != "x" ] || [ "x${LICHEE_ONE_ENV_SIZE}" != "x" ]; then
			generate_env_use_mkenvimage env_burn.cfg env.fex ${LICHEE_REDUNDANT_ENV_SIZE}
		else
			generate_env_for_uboot env_burn.cfg env.fex
		fi
	else
		if [ "x${LICHEE_REDUNDANT_ENV_SIZE}" != "x" ] || [ "x${LICHEE_ONE_ENV_SIZE}" != "x" ] ; then
			generate_env_use_mkenvimage env.cfg env.fex ${LICHEE_REDUNDANT_ENV_SIZE}
		else
			generate_env_for_uboot env.cfg env.fex
		fi
	fi

	dmverity_deal clean

}

function attribute_check()
{
	storage_type=$1
	dtb_attribute_1=$2
	dtb_attribute_2=$3
	attribute1_len=$4
	uboot_arch=$5
	uboot_dtb=$6

	if [ "x${LICHEE_BRANDY_UBOOT_VER}" = "x2023" ] ; then
		attribute1_value=$(sunxi_flashmap_tool -f get_dtb_node -d $CFG_TOP_DIR/brandy/brandy-2.0/u-boot-${LICHEE_BRANDY_UBOOT_VER}/arch/${uboot_arch}/dts/${uboot_dtb}.dtb -t ${storage_type} -a ${dtb_attribute_1})
		attribute2_value=$(sunxi_flashmap_tool -f get_dtb_node -d $CFG_TOP_DIR/brandy/brandy-2.0/u-boot-${LICHEE_BRANDY_UBOOT_VER}/arch/${uboot_arch}/dts/${uboot_dtb}.dtb -t ${storage_type} -a ${dtb_attribute_2})
	else
		attribute1_value=$(sunxi_flashmap_tool -f get_dtb_node -d $CFG_TOP_DIR/brandy/brandy-2.0/u-boot-2018/arch/${uboot_arch}/dts/${uboot_dtb}.dtb -t ${storage_type} -a ${dtb_attribute_1})
		attribute2_value=$(sunxi_flashmap_tool -f get_dtb_node -d $CFG_TOP_DIR/brandy/brandy-2.0/u-boot-2018/arch/${uboot_arch}/dts/${uboot_dtb}.dtb -t ${storage_type} -a ${dtb_attribute_2})
	fi

	if [ $(($attribute1_value + ($attribute1_len + 511) / 512)) -gt $attribute2_value ]; then
		echo ERROR flashmap $dtb_attribute_2 start block: $attribute2_value is less than $dtb_attribute_1 last block: $(($attribute1_value + ($attribute1_len + 511) / 512))
		exit 1
	fi
}

function flashmap_check()
{
	if [ "x${LICHEE_BRANDY_UBOOT_VER}" = "x2023" ] ; then
		UBOOT_DTB_NAME=$(cat "$CFG_TOP_DIR/brandy/brandy-2.0/u-boot-${LICHEE_BRANDY_UBOOT_VER}/bsp/configs/${LICHEE_BRANDY_DEFCONF}" | grep -w "CONFIG_DEFAULT_DEVICE_TREE" | awk -F= '{printf $2}')
	else
		UBOOT_DTB_NAME=$(cat "$CFG_TOP_DIR/brandy/brandy-2.0/u-boot-2018/configs/${LICHEE_BRANDY_DEFCONF}" | grep -w "CONFIG_DEFAULT_DEVICE_TREE" | awk -F= '{printf $2}')
	fi
	UBOOT_DTB_NAME="${UBOOT_DTB_NAME//\"/}"

	if [ "x${LICHEE_ARCH}" = "xriscv32" ] || [ "x${LICHEE_ARCH}" = "xriscv64" ] ; then
		UBOOT_ARCH_DIR=riscv
	elif [ "x${LICHEE_ARCH}" = "xarm" ] || [ "x${LICHEE_ARCH}" = "xarm64" ] ; then
		UBOOT_ARCH_DIR=arm
	else
		echo "LICHEE_ARCH is error"
		return 0
	fi

	if [ "x${UBOOT_VER}" = "x2023" ] ; then
		if [ "x${LICHEE_FLASH}" = "xdefault" ] ; then
			FLASHMAP_ENABLE=$(sunxi_flashmap_tool -f check_flashmap_enable -t mmc -d $CFG_TOP_DIR/brandy/brandy-2.0/u-boot-${LICHEE_BRANDY_UBOOT_VER}/arch/${UBOOT_ARCH_DIR}/dts/uboot-board.dtb)
		elif [ "x${LICHEE_FLASH}" = "xnor" ] ; then
			FLASHMAP_ENABLE=$(sunxi_flashmap_tool -f check_flashmap_enable -t flash -d $CFG_TOP_DIR/brandy/brandy-2.0/u-boot-${LICHEE_BRANDY_UBOOT_VER}/arch/${UBOOT_ARCH_DIR}/dts/uboot-board.dtb)
		else
			echo "LICHEE_FLASH type is error"
			return 0
		fi
	else
		if [ "x${LICHEE_FLASH}" = "xdefault" ] ; then
			FLASHMAP_ENABLE=$(sunxi_flashmap_tool -f check_flashmap_enable -t mmc -d $CFG_TOP_DIR/brandy/brandy-2.0/u-boot-2018/arch/${UBOOT_ARCH_DIR}/dts/${UBOOT_DTB_NAME}.dtb)
		elif [ "x${LICHEE_FLASH}" = "xnor" ] ; then
			FLASHMAP_ENABLE=$(sunxi_flashmap_tool -f check_flashmap_enable -t flash -d $CFG_TOP_DIR/brandy/brandy-2.0/u-boot-2018/arch/${UBOOT_ARCH_DIR}/dts/${UBOOT_DTB_NAME}.dtb)
		else
			echo "LICHEE_FLASH type is error"
			return 0
		fi
	fi

	if [ "x${PACK_SECURE}" = "xsecure" ]; then
		check_toc_size=`stat toc1.fex --format="%s"`
		if [ -f toc0_sdcard.fex ] ; then
			check_boot0_size=`stat toc0_sdcard.fex --format="%s"`
		elif [ -f toc0_nand.fex ] ; then
			check_boot0_size=`stat toc0_nand.fex --format="%s"`
		else
			check_boot0_size=`stat toc0.fex --format="%s"`
		fi
	elif [ "x${PACK_NOR}" = "xnor" ]; then
		check_toc_size=`stat boot_package_nor.fex --format="%s"`
		check_boot0_size=`stat boot0_spinor.fex --format="%s"`
	else
		check_toc_size=`stat boot_package.fex --format="%s"`
		check_boot0_size=`stat boot0_sdcard.fex --format="%s"`
	fi

	if [ "x${FLASHMAP_ENABLE}" = "xenabled" ] ; then
		echo "flashmap is enable"
		if [ "x${LICHEE_FLASH}" = "xdefault" ] ; then
			echo "TODO..."
		elif [ "x${LICHEE_FLASH}" = "xnor" ] ; then
			if [ "x${PACK_SECURE}" = "xsecure" ] ; then
				attribute_check flash uboot_start secure_logic_offset ${check_toc_size} ${UBOOT_ARCH_DIR} ${UBOOT_DTB_NAME}
				attribute_check flash boot0_start boot_param_start ${check_boot0_size} ${UBOOT_ARCH_DIR} ${UBOOT_DTB_NAME}
			else
				attribute_check flash uboot_start logic_offset ${check_toc_size} ${UBOOT_ARCH_DIR} ${UBOOT_DTB_NAME}
				attribute_check flash boot0_start boot_param_start ${check_boot0_size} ${UBOOT_ARCH_DIR} ${UBOOT_DTB_NAME}
			fi
		else
			echo "storage_type type is error"
			return 0
		fi
	else
		echo "flashmap is disable"
	fi
}

function do_finish()
{
	# Yeah, it should contain all files into full_img.fex for spinor
	# Because, as usually, spinor image size is very small.
	# If fail to create full_img.fex, we should fake it empty.

	# WTF, it is so ugly!!! It must be sunxi_mbr.fex & sys_partition.bin,
	# not sunxi_mbr_xxx.fex & sys_partition_xxx.bin. In order to advoid this
	# loathsome thing, we need to backup & copy files. Check whether
	# sys_partition_nor.bin is exist, and create sunxi_mbr.fex for Nor.
	local max_toc_size=2097152

	local IMG_NAME="${PACK_IC}_${PACK_TYPE}${PACK_PLATFORM_VERSION}_${PACK_BOARD}_${PACK_DEBUG}"
	if [ "x${PACK_MODE}" = "xdump" ] ; then
		IMG_NAME="${IMG_NAME}_${PACK_MODE}"
	fi

	if [ "x${PACK_FUNC}" = "xprvt" ]; then
		IMG_NAME="${IMG_NAME}_${PACK_FUNC}"
	fi

	if [ "x${PACK_SECURE}" = "xsecure" ] ; then
		IMG_NAME="${IMG_NAME}_${PACK_SECURE}"
	fi

	if [ "x${PACK_FUNC}" = "xprev_refurbish" ] ; then
		IMG_NAME="${IMG_NAME}_${PACK_FUNC}"
	fi

	if [ "x${PACK_NOR}" = "xnor" ] ; then
		IMG_NAME="${IMG_NAME}_${PACK_NOR}"
	fi

	if [ "x${PACK_SECURE}" != "xnone" ]; then
		local MAIN_VERION=$(readcfg dragon_toc.cfg rollback_ver ver)
		if [ ! -n "${MAIN_VERION}" ]; then
			local MAIN_VERION="$(echo '__unique:;@echo ${MAIN_VERSION}' | make -f - -f ${LICHEE_PACK_OUT_DIR}/version_base.mk --no-print-directory __unique)"
		fi
		IMG_NAME="${IMG_NAME}_v${MAIN_VERION}.img"
	else
		IMG_NAME="${IMG_NAME}.img"
	fi

	local IMG_PROGRAMMER_NAME="${IMG_NAME%.*}_programmer.img"

	echo "imagename = $IMG_NAME" >> ${LICHEE_PACK_OUT_DIR}/image.cfg
	echo "" >> ${LICHEE_PACK_OUT_DIR}/image.cfg

	local imagesize
	local toc_size
	local max_toc_size=2097152

	if [ "x${PACK_SECURE}" = "xsecure" ]; then
		toc_size=`stat toc1.fex --format="%s"`
	else
		toc_size=`stat boot_package.fex --format="%s"`
	fi

	if [ "$LICHEE_CHIP" == "sun55iw3p1" ]; then
		max_toc_size=3883264
	fi

	if [ ${toc_size} -gt ${max_toc_size} ];then
		pack_error "boot_package.fex/toc1.fex More than ${max_toc_size} bytes limit too large!!!"
		exit 1
	fi

	flashmap_check

	if [ "x${PACK_NOR}" = "xnor" ] ; then
		NOR_LOGIC_START=2016
		NOR_UBOOT_START=128
		NOR_FLASH_SIZE=65536 #32M
		NOR_LOGIC_START_KB=`expr ${NOR_LOGIC_START} / 2`
		NOR_UBOOT_START_KB=`expr ${NOR_UBOOT_START} / 2`

		local uboot_dts=""
		if [ -n "${LICHEE_BRANDY_UBOOT_VER}" ] && [ ${LICHEE_BRANDY_UBOOT_VER} -ge 2023 ]; then
			uboot_dts="${LICHEE_BOARD_CONFIG_DIR}/uboot-${LICHEE_BRANDY_UBOOT_VER}/uboot-board.dts"
		else
			uboot_dts="${LICHEE_BOARD_CONFIG_DIR}/uboot-board.dts"
		fi

		if [ -f ${uboot_dts} ] && [ x"$(grep "nor_map" ${uboot_dts})" != x"" ]; then
			echo "get flashmap from ${uboot_dts}"
			NOR_FLASH_SIZE=$(awk '/nor_map {/,/}/ {print NR ": " $0}' ${uboot_dts} \
				| grep  "\bflash_size\b" | grep -oP "(?<=\<)\d+(?=\>)")

			NOR_LOGIC_START=$(awk '/nor_map {/,/}/ {print NR ": " $0}' ${uboot_dts} \
				| grep  "\blogic_offset\b" | grep -oP "(?<=\<)\d+(?=\>)")

			NOR_UBOOT_START=$(awk '/nor_map {/,/}/ {print NR ": " $0}' ${uboot_dts} \
				| grep  "\buboot_start\b" | grep -oP "(?<=\<)\d+(?=\>)")

			[ x"${NOR_FLASH_SIZE}" = x"" -o x"${NOR_LOGIC_START}" = x"" -o x"${NOR_UBOOT_START}" = x"" ] && {
				pack_warn "flash_size,logic_offset,uboot_start maybe not set in uboot-board.dts"
				NOR_LOGIC_START=2016
				NOR_UBOOT_START=128
				NOR_FLASH_SIZE=65536 #32M
			}

			NOR_LOGIC_START_KB=`expr ${NOR_LOGIC_START} / 2`
			NOR_UBOOT_START_KB=`expr ${NOR_UBOOT_START} / 2`
			echo "flash size:${NOR_FLASH_SIZE}, logic start:${NOR_LOGIC_START}, uboot start:${NOR_UBOOT_START}"
		fi

		update_mbr sys_partition_nor.bin 1 sunxi_mbr_nor.fex dlinfo.fex \
				${NOR_FLASH_SIZE} ${NOR_LOGIC_START} 1

		if [ $? -ne 0 ]; then
			pack_error "update_mbr failed"
			exit 1
		fi
		echo '----------programmer nor image is full_img.fex ----------'
		if [ "x${PACK_KERN}" = "xlinux-3.4" ] ; then
		#when use devicetree, the size of uboot+dtb is larger then 256K
			#BOOT1_FILE=u-boot-spinor.fex
			#LOGIC_START=240 #240+16=256K
			#merge_package full_img.fex boot0_spinor.fex \
			#        u-boot-spinor.fex sunxi_mbr_nor.fex sys_partition_nor.bin
			merge_full_img --out full_img.fex --boot0 boot0_spinor.fex --boot1 u-boot-spinor.fex \
							--mbr sunxi_mbr_nor.fex  --partition sys_partition_nor.bin \
							--logic_start 240 > /dev/null
		else
			merge_full_img --out full_img.fex --boot0 boot0_spinor.fex --boot1 boot_package_nor.fex \
				--mbr sunxi_gpt.fex --partition sys_partition_nor.bin \
				--logic_start ${NOR_LOGIC_START_KB} --uboot_start ${NOR_UBOOT_START_KB} > /dev/null
		fi

		if [ $? -ne 0 ]; then
			pack_error "merge_full_img failed"
			exit 1
		fi
		mv sys_partition_nor.fex sys_partition.fex
	fi

	if [ ! -f sys_partition_nor.bin ]; then
		update_mbr          sys_partition.bin 4
		if [ $? -ne 0 ]; then
			pack_error "update_mbr failed"
			exit 1
		fi

		#15269888 is from emmc datasheet, sec_count in Extended CSD is 0xe90000 = 15269888.
		#40960 is the mbr location for emmc
		#0  is emmc/nand ; 1 is spinor
		update_mbr sys_partition.bin 4 sunxi_mbr.fex dlinfo.fex 15269888 40960 0
		if [ $? -ne 0 ]; then
			pack_error "update_mbr_gpt failed"
			exit 1
		fi
	fi

	if [ x"${PACK_PLATFORM}" = x"openwrt" ]; then
		echo "===================================="
		echo "show sys_partition.fex message"
		show_partition_message sys_partition.fex
	fi

	local e cfgadd cfgget lastcfgline localfile filename
	local imgcfg_add_list=(
		# localfile             filename-in-cfg        maintype  subtype
		'vmlinux.fex            vmlinux.fex            12345678  123456789VMLINUX'
		'vendor_boot-debug.fex  vendor_boot-debug.fex  RFSFAT16  VENDOR_BOOTDEBUG'
		'dragon_toc.cfg         dragon_toc.fex         12345678  12345678DGTOCCFG'
		)

	for e in "${imgcfg_add_list[@]}"; do
		localfile="$(awk '{print $1}' <<< $e)"
		filename="$(awk '{print $2}' <<< $e)"
		maintype="$(awk '{print $3}' <<< $e)"
		subtype="$(awk '{print $4}' <<< $e)"
		cfgget="$(sed -n '/^\s*{\s*filename\s*=\s*"'$filename'"\s*,/p' image.cfg)"
		lastcfgline="$(sed -n '/^\s*{\s*filename\s*=/=' image.cfg | tail -1)"

		[ ! -f "$localfile" -o -n "$cfgget" -o -z "$lastcfgline" ] && continue
		[ "$localfile" != "$filename" ] && ln -sf $localfile $filename
		cfgadd='    {filename = "'$filename'",'
		cfgadd+='     maintype = "'$maintype'",'
		cfgadd+='     subtype  = "'$subtype'",},'
		sed -i -e  ''"${lastcfgline}"'a\' -e "$cfgadd" image.cfg
	done

	dragon image.cfg    sys_partition.fex
	if [ $? -eq 0 ]; then
		if [ -e ${IMG_NAME} ]; then
			mv ${IMG_NAME} $LICHEE_OUT_DIR/$LICHEE_IC/$LICHEE_BOARD/$LICHEE_LINUX_DEV/${IMG_NAME}
			rm -f $LICHEE_OUT_DIR/${IMG_NAME}
			ln -f $LICHEE_OUT_DIR/$LICHEE_IC/$LICHEE_BOARD/$LICHEE_LINUX_DEV/${IMG_NAME}  $LICHEE_OUT_DIR/${IMG_NAME}
			imagesize=$(du --apparent-size -sh $LICHEE_OUT_DIR/$LICHEE_IC/$LICHEE_BOARD/$LICHEE_LINUX_DEV/${IMG_NAME} | awk '{print $1}')
			echo '----------image is at----------'
			echo -e '\033[0;31;1m'
			echo -e "$imagesize\t${LICHEE_OUT_DIR}/${IMG_NAME}"
			echo -e '\033[0m'
		fi
	fi

	if [ -f $LICHEE_PACK_OUT_DIR/full_img.fex ]; then
		cp $LICHEE_PACK_OUT_DIR/full_img.fex $LICHEE_OUT_DIR/${LICHEE_IC}/${LICHEE_BOARD}/${LICHEE_LINUX_DEV}/full_img.img

		imagesize=$(du --apparent-size -sh $LICHEE_PACK_OUT_DIR/full_img.fex | awk '{print $1}')
		echo '----------full image is at----------'
		echo -e '\033[0;31;1m'
		echo -e "$imagesize\t$LICHEE_PACK_OUT_DIR/full_img.fex"
		echo -e '\033[0m'
	fi

	cd ..

	if [ "x${PACK_PROGRAMMER}" = "xprogrammer" ]; then
		if [ -f  $LICHEE_PACK_OUT_DIR/super.fex ]; then
			mv $LICHEE_PACK_OUT_DIR/super.fex $LICHEE_PACK_OUT_DIR/super.bak.fex
			simg2img  $LICHEE_PACK_OUT_DIR/super.bak.fex $LICHEE_PACK_OUT_DIR/super.fex
		fi
		echo "waiting to ceate programmer img..."
		img_to_programmer ${IMG_PROGRAMMER_NAME} $LICHEE_OUT_DIR/${LICHEE_IC}/${LICHEE_BOARD}/${LICHEE_LINUX_DEV}/${IMG_NAME}
		if [ $? -eq 0 ]; then
			if [ -e ${IMG_PROGRAMMER_NAME} ]; then
				mv $LICHEE_PACK_OUT_DIR/${IMG_PROGRAMMER_NAME} $LICHEE_OUT_DIR/${LICHEE_IC}/${LICHEE_BOARD}/${LICHEE_LINUX_DEV}/${IMG_PROGRAMMER_NAME}
				imagesize=$(du --apparent-size -sh $LICHEE_OUT_DIR/${LICHEE_IC}/${LICHEE_BOARD}/${LICHEE_LINUX_DEV}/${IMG_PROGRAMMER_NAME} | awk '{print $1}')
				echo '----------programmer image is at----------'
				echo -e '\033[0;31;1m'
				echo -e "$imagesize\t${LICHEE_OUT_DIR}/${IMG_PROGRAMMER_NAME}"
				echo -e '\033[0m'
			fi
		fi
	fi
	cd ..
	do_finish_SATA
	printf "pack finish\n"
	[ -e ${LICHEE_TOP_DIR}/build/.hooks/post-dragon ] &&
		source ${LICHEE_TOP_DIR}/build/.hooks/post-dragon
	return 0
}

function do_finish_SATA()
{
	if [ "x$BUILD_SATA" = "xtrue" ];then
		SATA_TAR=$LICHEE_TOP_DIR/SATA/linux/${LICHEE_CHIP}.tar
		if [ -f $SATA_TAR ];then
			echo '----------SATA is at----------'
			echo -e '\033[0;31;1m'
			echo $SATA_TAR
			echo -e '\033[0m'
		else
			echo PACK SATA failed!
		fi
	fi
}

function dmverity_deal()
{
	local script_name=scripts/build.sh
	local script_path=$LICHEE_KERN_DIR

	if [ ! -x $script_path/$script_name ]; then
		script_path=$LICHEE_BUILD_DIR
		script_name=mkkernel.sh
	fi

	[ ! -x $script_path/$script_name ] && return 255
	[ -z "$(grep "^\s*deal_verity)\s*$" $script_path/$script_name)" ] && return 1

	(cd $script_path && ./$script_name "deal_verity" $@)
}

function dmverity_get_blk_count()
{
	local size=`du --apparent-size -b $1 | awk '{print $1}'`
	local BLK_SIZE=$2

	if [ `expr ${size} % ${BLK_SIZE}` = "0" ]; then
			local blks=`(expr ${size} / ${BLK_SIZE})`
	else
			local blks=`(expr ${size} / ${BLK_SIZE} + 1 )`
	fi

	echo $blks
}

function dmverity_determ_blk_size()
{
	local type_info=`file -L $1`

	#check rootfs file system type to determ block size
	if [ "x""`echo ${type_info}| grep "ext4 filesystem"`" != "x" ];then
		block_size=`tune2fs -l $1|grep "Block size"|awk {'print $3'}`
		echo ${block_size}
	else
		echo "not support file system type"
		return -1
	fi

}
function dmverity_genHashTable()
{
	local fs_name=$1
	local tree_name=$2
	local table_name=$3
	local block_size=`dmverity_determ_blk_size ${fs_name}`
	if [ ${block_size} -lt 0 ];then
		return -1
	fi
	veritysetup format --data-block-size=${block_size} --hash-block-size=${block_size} ${fs_name} ${tree_name} > ${table_name}
	return $?
}

function dmverity_genDownloadFile()
{
	local fs_name=$1
	local sign_name=$2
	local table_name=$3
	local tree_name=$4
	local download_file_name=$5

	local BLK_SIZE=`dmverity_determ_blk_size ${fs_name}`
	if [ ${BLK_SIZE} -lt 0 ];then
		return -1
	fi
	local SIGN_BLK=`dmverity_get_blk_count ${sign_name} ${BLK_SIZE}`
	local TABLE_BLK=`dmverity_get_blk_count ${table_name} ${BLK_SIZE}`
	local TREE_BLK=`dmverity_get_blk_count ${tree_name} ${BLK_SIZE}`

	# 3.1 copy sign
	dd if=${sign_name} of=${download_file_name}"tmp" bs=${BLK_SIZE} count=${SIGN_BLK} >/dev/null 2>&1

	# 3.2 copy table size
	local TABLE_SIZE=`du --apparent-size -b ${table_name} | awk '{print $1}'`
	local HIGH_BYTES=`expr $TABLE_SIZE / 256 `
	local LOW_BYTES=`expr $TABLE_SIZE % 256 `
	if [ $HIGH_BYTES -gt 256 ]; then
		echo "ERROR rootfs_hash_table size should < 64KB"
		return -1
	fi
	local HIGH_BYTES_H=`echo "obase=16;ibase=10;$HIGH_BYTES" | bc`
	local LOW_BYTES_H=`echo "obase=16;ibase=10;$LOW_BYTES" | bc`
	echo -e -n "\x$LOW_BYTES_H\x$HIGH_BYTES_H" >> ${download_file_name}"tmp"

	# 3.3 copy rootfs_hash_table
	dd if=${table_name} of=${download_file_name}"tmp"  bs=${BLK_SIZE} seek=${SIGN_BLK} count=${TABLE_BLK} > /dev/null 2>&1

	# 3.4 copy rootfs_hash_tree.bin
	dd if=${tree_name} of=${download_file_name}"tmp"  bs=${BLK_SIZE} seek=`expr ${SIGN_BLK} + ${TABLE_BLK}` count=${TREE_BLK} > /dev/null 2>&1

	dd of=${download_file_name} if=${download_file_name}"tmp" bs=${BLK_SIZE} count=`expr ${SIGN_BLK} + ${TABLE_BLK} + ${TREE_BLK}`>/dev/null 2>&1
	rm ${download_file_name}"tmp"
}

function do_signature_dsp()
{
	local DSP0_BIN=${LICHEE_PACK_OUT_DIR}/amp_dsp0.fex;
	local DSP1_BIN=${LICHEE_PACK_OUT_DIR}/amp_dsp1.fex;
	local CFG_FILE=${LICHEE_CHIP_CONFIG_DIR}/configs/default/image_header_secure.cfg;

	if [ -f ${CFG_FILE} ] ; then
		cp -v ${CFG_FILE} image_header_secure.cfg
	else
		printf "can not found image_header_secure cfg\n"
		return 1
	fi

	if [ -f ${DSP0_BIN} ] ; then
		mkimage_header -C 5 -c image_header_secure.cfg -s rsa -k $CFG_KEY_DIR
		if [ $? -ne 0 ]
		then
			pack_error "mkimage_header signature dsp error\n"
			exit 1
		fi
		mv amp_dsp0.fex.pack amp_dsp0.fex
	else
		printf "can not found amp_dsp0 bin\n"
		return 3
	fi

	if [ -f ${DSP1_BIN} ] ; then
		mv amp_dsp0.fex.pack amp_dsp0.fex
	fi

}

function do_signature_riscv()
{
	local RV0_BIN=${LICHEE_PACK_OUT_DIR}/amp_rv0.fex;
	local RV1_BIN=${LICHEE_PACK_OUT_DIR}/amp_rv1.fex;
	local CFG_FILE=${LICHEE_CHIP_CONFIG_DIR}/configs/default/image_header_secure.cfg;
	local key_type=$(readcfg dragon_toc.cfg key_para key_toc1 | cut -c 1-3)
	if [ x${key_type} == "xecc" ]; then
		sign_alg=ecc
	else
		sign_alg=rsa
	fi

	if [ -f ${CFG_FILE} ] ; then
		cp -v ${CFG_FILE} image_header_secure.cfg
	else
		printf "can not found image_header_secure cfg\n"
		return 1
	fi

	if [ -f ${RV0_BIN} ] ; then
		mkimage_header -C 5 -c image_header_secure.cfg -s $sign_alg -k $CFG_KEY_DIR
		if [ $? -ne 0 ]
		then
			pack_error "mkimage_header signature rv error\n"
			exit 1
		fi
		mv amp_rv0.fex.pack amp_rv0.fex
	else
		printf "can not found amp_rv0 bin\n"
		return 3
	fi

	if [ -f ${RV1_BIN} ] ; then
		mv amp_rv1.fex.pack amp_rv1.fex
	fi

}

function do_signature_ft()
{
	if [ ! -e ${LICHEE_PACK_OUT_DIR}/ft_${PACK_CHIP}.bin ]; then
		printf "can not found ft bin\n"
		return 1
	fi

	if [ -e ${LICHEE_PACK_OUT_DIR}/dragon_toc_ft.cfg ]; then
		printf "can not found dragon_toc_ft cfg\n"
	fi

	printf "prepare for signature for ft bin\n"
	mv ${LICHEE_PACK_OUT_DIR}/ft_${PACK_CHIP}.bin ${LICHEE_PACK_OUT_DIR}/ft.bin
	dragonsecboot -toc0 dragon_toc_ft.cfg $CFG_KEY_DIR ${LICHEE_PACK_OUT_DIR}/version_base.mk > /dev/null
	if [ $? -ne 0 ]; then
		pack_error "dragon toc0_ft run error\n"
		exit 1
	fi

	mv toc0.fex toc0_ft.fex
}

function do_signature_fel()
{
	printf "prepare for signature for fex tools\n"
	local ROOT_KEY_NAME="";
	local UBOOT_NAME="u-boot";
	local sign_tools=$(readcfg dragon_toc.cfg sign_fel_tools sign_tools)

	if [ -f u-boot-efex.fex ]; then
		UBOOT_NAME="u-boot-efex"
	fi
	echo UBOOT_NAME ${UBOOT_NAME}

	if [ x${sign_tools} == "xdragonsboot" ]; then
		printf "using dragonsboot to sign fel\n"

		if [ -f ${CFG_KEY_DIR}/RootKey_Level_0.pem ]; then
			ROOT_KEY_NAME=${CFG_KEY_DIR}/RootKey_Level_0.pem
		elif [ -f ${CFG_KEY_DIR}/Trustkey.pem ]; then
			ROOT_KEY_NAME=${CFG_KEY_DIR}/Trustkey.pem
		else
			pack_error "can not found root key to sign fex tool"
			exit 1
		fi
		echo rootkeyname ${ROOT_KEY_NAME}

		dragonsecboot -sign fes1.fex ${ROOT_KEY_NAME} ${LICHEE_PACK_OUT_DIR}/version_base.mk > /dev/null
		if [ $? -eq 0 ]; then
			dragonsecboot -sign ${UBOOT_NAME}.fex ${ROOT_KEY_NAME} ${LICHEE_PACK_OUT_DIR}/version_base.mk > /dev/null
			if [ $? -ne 0 ]
			then
				pack_error "dragonsecboot uboot fail"
			fi
		fi
	else
		printf "using sig_fel_image to sign fel\n"
		if [ -f ${CFG_KEY_DIR}/RootKey_Level_0.bin ]; then
			ROOT_KEY_NAME=${CFG_KEY_DIR}/RootKey_Level_0.bin
		elif [ -f ${CFG_KEY_DIR}/Trustkey.bin ]; then
			ROOT_KEY_NAME=${CFG_KEY_DIR}/Trustkey.bin
		else
			pack_error "can not found root key to sign fex tool"
			exit 1
		fi
		echo rootkeyname ${ROOT_KEY_NAME}

		sig_fel_image --input fes1.fex --rsakey ${ROOT_KEY_NAME} --output fes1_sign.fex --version_base ${LICHEE_PACK_OUT_DIR}/version_base.mk
		if [ $? -ne 0 ]
		then
			pack_error "sig_fel_image fes fail"
			exit 1
		fi
		sig_fel_image --input ${UBOOT_NAME}.fex --rsakey ${ROOT_KEY_NAME} --output ${UBOOT_NAME}_sign.fex --version_base ${LICHEE_PACK_OUT_DIR}/version_base.mk
		if [ $? -ne 0 ]
		then
			pack_error "sig_fel_image uboot fail"
		fi
	fi

	if [ -f fes1_sign.fex ]; then
		cp fes1_sign.fex fes1.fex
	fi

	if [ -f  ${UBOOT_NAME}_sign.fex ]; then
		cp ${UBOOT_NAME}_sign.fex ${UBOOT_NAME}.fex
	fi
}

function readcfg()
{
	local fid=$1
	local section=$2
	local option=$3

	test ! -f $fid && echo "file not exits:$fid" && exit 1
	if [ $# -eq 3 ] ; then
		local src=$(cat $fid | awk '/\['$section'\]/{f=1;next} /\[*\]/{f=0} f' |
		grep ^$option |
		grep '='     |
		cut -d'=' -f2|
		cut -d'#' -f1|
		cut -d';' -f1|
		awk '{gsub(/^\s+|\s+$/, "");print}')
		echo -n $src
		test ${#src} -eq 0 && return 1 || return 0
	else
		echo "the input parameters should be 3"
		exit 1
	fi
}

function get_item_from_cfg()
{
	name=()
	bin=()
	cert=()
	counts=0

	local toc_cfg=$1
	local field=$2
	local key=$3

	toc1_item_content=$(readcfg ${toc_cfg} ${field} ${key})
	i=0
	IFS=', ' read -r -a parts <<< $toc1_item_content
	for part in "${parts[@]}"; do
		if [ $(($i % 3)) -eq 0 ]; then
			name[counts]=$part
		elif [ $(($i % 3)) -eq 1 ]; then
			bin[counts]=$part
		else
			cert[counts]=$part
			counts=$((counts + 1))
		fi
		i=$((i + 1))
	done
}

function create_toc0()
{
	local toc_cfg=$1
	local key=""
	local cert_type=""
	local key_type=""
	local psck_mode=""

	rm -rf toc0

	if [ ! -d "toc0" ]; then
		mkdir -p toc0
	fi

	if [ ! -d "temp" ]; then
		mkdir -p temp
	fi

	get_item_from_cfg ${toc_cfg} toc0 item

	key=$(readcfg ${toc_cfg} key_toc0 ${name[0]})
	cert_type=$(readcfg ${toc_cfg} cert_type cert_type_toc0)
	key_type=$(readcfg ${toc_cfg} key_para key_toc0 | cut -c 1-3)
	if [ x${key_type} == "xrsa" ]; then
		psck_mode=RSA-PKCS
	elif [ x${key_type} == "xecc" ]; then
		psck_mode=ECDSA
	else
		pack_error "key_toc0 type error"
		exit 1
	fi

	#gen sboot hash
	dragon_securetool hash --mode 256 --in ${bin[0]} --out ./temp/${bin[0]}.hash.out
	if [ $? -ne 0 ]
	then
		pack_error "gen sboot hash error"
		exit 1
	fi

	#req no sign cert, ext is sboot_hash; use pubkey
	dragon_securetool req_cert --type ${cert_type} --cfg ${toc_cfg} --pubkey ${CFG_KEY_DIR}/${key}.pem.pub --ext ./temp/${bin[0]}.hash.out --out ./temp/${name[0]}.req
	if [ $? -ne 0 ]
	then
		pack_error "req no sign cert for toc0 error"
		exit 1
	fi

	#gen no sign cert hash, witch is to be signed
	dragon_securetool hash --mode 256 --type ${cert_type} --in ./temp/${name[0]}.req --out ./temp/${name[0]}.req.hash
	if [ $? -ne 0 ]
	then
		pack_error "gen no sign cert hash for toc0 error"
		exit 1
	fi

	#sign cert(to be signed) hash
	if [ "x$SOFTHSM_FLAG" == "x1" ]; then
		local id=$(echo "$key" | md5sum | awk '{print $1}')
		pkcs11-tool --label ${key} --id ${id} -s -p ${PIN} -m ${psck_mode} --module ${MODULES} --input-file ./temp/${name[0]}.req.hash --output-file ./temp/${name[0]}.req.sign
		if [ $? -ne 0 ]
		then
			pack_error "softhsm sign cert(to be signed) hash for toc0 error"
			exit 1
		fi
	else
		dragon_securetool sign --cfg ${toc_cfg} --privatekey ${CFG_KEY_DIR}/${key}.pem --in ./temp/${name[0]}.req.hash --out ./temp/${name[0]}.req.sign
		if [ $? -ne 0 ]
		then
			pack_error "sign cert(to be signed) hash for toc0 error"
			exit 1
		fi
	fi

	#create cert with sign
	dragon_securetool create_cert --type ${cert_type} --cfg ${toc_cfg} --pubkey ${CFG_KEY_DIR}/${key}.pem.pub --reqfile ./temp/${name[0]}.req --signfile ./temp/${name[0]}.req.sign --out ./toc0/${cert[0]}
	if [ $? -ne 0 ]
	then
		pack_error "create cert with sign for toc0 error"
		exit 1
	fi

	#create toc0.fex(toc0_head + sboot.crtpt + sboot)
	dragon_securetool create_toc0 --cfg ${toc_cfg} --out ./toc0.fex
	if [ $? -ne 0 ]
	then
		pack_error "dragon toc0 run error"
		exit 1
	fi
}

function do_signature_sboot()
{
	local sboot_file=$1;
	local flash_type=$2;

	#dram_param
	if [ -f ${LICHEE_TOOLS_DIR}/pack/pctools/linux/mod_update/update_sboot ]; then
		update_sboot $sboot_file  sys_config.bin  > /dev/null
		if [ $? -ne 0 ]
		then
			pack_error "update sboot run error"
			exit 1
		fi
	fi

	update_chip $sboot_file > /dev/null

	#dragon_toc only load sboot.bin
	[ "$(readlink -f $sboot_file)" != "$(readlink -f sboot.bin)" ] && \
	mv $sboot_file sboot.bin

	#readcfg determines whether the cfg file is legacy or new
	readcfg dragon_toc.cfg key_para key > /dev/null
	if [ $? -ne 0 ]; then
		dragonsecboot -toc0 dragon_toc.cfg $CFG_KEY_DIR ${LICHEE_PACK_OUT_DIR}/version_base.mk > /dev/null
		if [ $? -ne 0 ]
		then
			pack_error "dragon toc0 run error"
			exit 1
		fi
	else
		create_toc0 dragon_toc.cfg

	fi

	update_toc0  toc0.fex           sys_config.bin
	if [ $? -ne 0 ]
	then
		pack_error "update toc0 run error"
		exit 1
	fi

	[ "$(readlink -f $sboot_file)" != "$(readlink -f sboot.bin)" ] && \
	mv sboot.bin $sboot_file
	if [ -f toc0_$flash_type.fex ]; then
		rm -rf toc0_$flash_type.fex
	fi
	mv toc0.fex toc0_$flash_type.fex
	mv toc0 toc0_$flash_type
}

function do_signature_toc0()
{
	if [ -f sboot.bin ]; then
		do_signature_sboot sboot.bin bak
		mv sboot.bin sboot_bak.bin
	fi

	if [ -f sboot_sdcard.bin ]; then
		if [ -f cardscript.fex ]; then
			sed -i "s/TOC0_00000000000/TOC0_SDCARD00000/g" cardscript.fex
		fi
		do_signature_sboot sboot_sdcard.bin sdcard
	fi

	if [ -f sboot_nand.bin ]; then
		do_signature_sboot sboot_nand.bin nand

	fi

	if [ -f sboot_ufs.bin ]; then
		do_signature_sboot sboot_ufs.bin ufs
	fi

	if [ -f sboot_nor.bin ]; then
		do_signature_sboot sboot_nor.bin nor
	fi

	mv sboot_bak.bin sboot.bin
	mv toc0_bak.fex toc0.fex
	mv toc0_bak toc0
}

function toc1_create_cert_for_per_bin()
{
	local toc_cfg=$1
	local key=""
	local cert_type=""
	local key_type=""
	local psck_mode=""

	cert_type=$(readcfg ${toc_cfg} cert_type cert_type_toc1)
	key_type=$(readcfg ${toc_cfg} key_para key_toc1 | cut -c 1-3)
	if [ x${key_type} == "xrsa" ]; then
		psck_mode=RSA-PKCS
	elif [ x${key_type} == "xecc" ]; then
		psck_mode=ECDSA
	else
		pack_error "key_toc1 type error"
		exit 1
	fi

	for ((count=0; count < counts; count++)); do
		key=$(readcfg ${toc_cfg} key_toc1 ${name[count]})
		#gen ${bin[count]} hash
		dragon_securetool hash --mode 256 --in ${bin[count]} --out temp/${name[count]}_hash.out
		if [ $? -ne 0 ]
		then
			pack_error "gen hash ${name[count]} error"
			exit 1
		fi

		#req no sign cert, ext is sboot_hash; use pubkey
		dragon_securetool req_cert --type ${cert_type} --cfg ${toc_cfg} --pubkey ${CFG_KEY_DIR}/$key.pem.pub --ext temp/${name[count]}_hash.out --out temp/${cert[count]}.req
		if [ $? -ne 0 ]
		then
			pack_error "req no sign cert ${name[count]} error"
			exit 1
		fi

		#gen no sign cert hash, witch is to be signed
		dragon_securetool hash --mode 256 --type ${cert_type} --in temp/${cert[count]}.req --out temp/to_be_signed_${name[count]}_hash.out
		if [ $? -ne 0 ]
		then
			pack_error "gen no sign cert hash ${name[count]} error"
			exit 1
		fi

		#sign cert(to be signed) hash
		if [ "x$SOFTHSM_FLAG" == "x1" ]; then
			local id=$(echo "$key" | md5sum | awk '{print $1}')
			pkcs11-tool --label ${key} --id ${id} -s -p ${PIN} -m ${psck_mode} --module ${MODULES} --input-file temp/to_be_signed_${name[count]}_hash.out --output-file temp/${name[count]}_sign.out
			if [ $? -ne 0 ]
			then
				pack_error "softhsm sign cert(to be signed) hash ${name[count]} error"
				exit 1
			fi
		else
			dragon_securetool sign --cfg ${toc_cfg} --privatekey ${CFG_KEY_DIR}/$key.pem --in temp/to_be_signed_${name[count]}_hash.out --out temp/${name[count]}_sign.out
			if [ $? -ne 0 ]
			then
				pack_error "sign cert(to be signed) hash ${name[count]} error"
				exit 1
			fi
		fi

		#create cert with sign
		dragon_securetool create_cert --type ${cert_type} --cfg ${toc_cfg} --pubkey ${CFG_KEY_DIR}/${key}.pem.pub --reqfile temp/${cert[count]}.req --signfile temp/${name[count]}_sign.out --out toc1/cert/${cert[count]}
		if [ $? -ne 0 ]
		then
			pack_error "create cert with sign ${name[count]} error"
			exit 1
		fi
	done
}

function toc1_create_cert_for_rootkey()
{
	local toc_cfg=$1
	local key=""
	local cert_type=""
	local key_type=""
	local psck_mode=""

	cert_type=$(readcfg ${toc_cfg} cert_type cert_type_toc1)
	get_item_from_cfg ${toc_cfg} toc1 rootkey
	key=$(readcfg ${toc_cfg} key_toc0 rootkey)
	key_type=$(readcfg ${toc_cfg} key_para key_toc0 | cut -c 1-3)
	if [ x${key_type} == "xrsa" ]; then
		psck_mode=RSA-PKCS
	elif [ x${key_type} == "xecc" ]; then
		psck_mode=ECDSA
	else
		pack_error "key_toc0 type error"
		exit 1
	fi

	#rootkey no sign cert
	#req no sign rootkey cert, insert extensions in the dragon_toc.cfg; use pubkey
	dragon_securetool req_rootkey_cert --type ${cert_type} --cfg ${toc_cfg} --keypath ${CFG_KEY_DIR} --pubkey ${CFG_KEY_DIR}/${key}.pem.pub
	if [ $? -ne 0 ]
	then
		pack_error "req rootkey cert error"
		exit 1
	fi

	mv toc1/cert/${cert[0]} temp/${cert[0]}.req
	#gen no sign rootkey cert hash, witch is to be signed; Non-x509 certificates do not need to skip 4 bytes
	dragon_securetool hash --mode 256 --type ${cert_type} --in temp/${cert[0]}.req --out temp/to_be_signed_${name[0]}_hash.out
	if [ $? -ne 0 ]
	then
		pack_error "gen no sign rootkey cert hash error"
		exit 1
	fi

	#sign rootkey cert(to be signed) hash
	if [ "x$SOFTHSM_FLAG" == "x1" ]; then
		local id=$(echo "$key" | md5sum | awk '{print $1}')
		pkcs11-tool --label ${key} --id ${id} -s -p ${PIN} -m ${psck_mode} --module ${MODULES} --input-file temp/to_be_signed_${name[0]}_hash.out --output-file temp/${name[0]}_sign.out
		if [ $? -ne 0 ]
		then
			pack_error "softhsm sign rootkey cert(to be signed) hash error"
			exit 1
		fi
	else
		dragon_securetool sign --cfg ${toc_cfg} --privatekey ${CFG_KEY_DIR}/${key}.pem --in temp/to_be_signed_${name[0]}_hash.out --out temp/${name[0]}_sign.out
		if [ $? -ne 0 ]
		then
			pack_error "sign rootkey cert(to be signed) hash error"
			exit 1
		fi
	fi

	#create rootkey cert with sign
	dragon_securetool create_cert --type ${cert_type} --cfg ${toc_cfg} --pubkey ${CFG_KEY_DIR}/${key}.pem.pub --reqfile temp/${cert[0]}.req --signfile temp/${name[0]}_sign.out --out toc1/cert/${cert[0]}
	if [ $? -ne 0 ]
	then
		pack_error "create rootkey cert with sign error"
		exit 1
	fi
}

function do_signature_toc1()
{
	rm -rf toc1

	if [ ! -d "toc1/cert" ]; then
		mkdir -p toc1/cert
	fi

	if [ ! -d "temp" ]; then
		mkdir -p temp
	fi

	#create cert for toc1 item
	get_item_from_cfg dragon_toc.cfg toc1 item
	toc1_create_cert_for_per_bin dragon_toc.cfg

	#create cert for toc1 onlykey
	get_item_from_cfg dragon_toc.cfg toc1 onlykey
	toc1_create_cert_for_per_bin dragon_toc.cfg

	toc1_create_cert_for_rootkey dragon_toc.cfg

	#create toc1.fex(toc1_head + rootkey.crtpt + ..)
	dragon_securetool create_toc1 --cfg dragon_toc.cfg --out toc1.fex
	if [ $? -ne 0 ]
	then
		pack_error "dragon toc1 run error"
		exit 1
	fi
}

function do_signature()
{
	printf "prepare for signature by openssl\n"
	if [ ! -d $CFG_KEY_DIR ] ; then
		pack_error "No key exist, please run './build/createkeys' to generate keys first."
		exit 1
	fi
	if [ "x${PACK_SIG}" = "xprev_refurbish" ] ; then
		if [ "x${LICHEE_ARCH}" = "xarm64" ] ; then
			cp -v ${LICHEE_COMMON_CONFIG_DIR}/sign_config/dragon_toc_a64_no_secureos.cfg dragon_toc.cfg
		else
			cp -v ${LICHEE_COMMON_CONFIG_DIR}/sign_config/dragon_toc_no_secureos.cfg dragon_toc.cfg
		fi
	else
		if [ "x${LICHEE_ARCH}" = "xarm64" ] ; then
			if [ -f ${LICHEE_CHIP_CONFIG_DIR}/configs/default/dragon_toc.cfg ] ; then
				cp -v ${LICHEE_CHIP_CONFIG_DIR}/configs/default/dragon_toc.cfg dragon_toc.cfg
			else
				cp -v ${LICHEE_COMMON_CONFIG_DIR}/sign_config/dragon_toc_a64.cfg dragon_toc.cfg
			fi
		else
			if [ -f ${LICHEE_CHIP_CONFIG_DIR}/configs/default/dragon_toc.cfg ] ; then
				cp -v ${LICHEE_CHIP_CONFIG_DIR}/configs/default/dragon_toc.cfg dragon_toc.cfg
			else
				cp -v ${LICHEE_COMMON_CONFIG_DIR}/sign_config/dragon_toc.cfg dragon_toc.cfg
			fi
		fi
	fi
	if [ "x${PACK_NOR}" = "xnor" ] ; then
		cp -vf ${LICHEE_PACK_OUT_DIR}/dragon_toc_nor.cfg ${LICHEE_PACK_OUT_DIR}/dragon_toc.cfg
	fi

	if [ -f ${CFG_KEY_DIR}/softhsm2.cfg ]; then
		# fix tokendir
		tokendir=$(grep tokendir ${CFG_KEY_DIR}/softhsm2.cfg | awk '{print $3}')
		if [ "x$tokendir" != "x${CFG_KEY_DIR}/.token" ]; then
			sed -i "s#${tokendir}#${CFG_KEY_DIR}/.token#g" ${CFG_KEY_DIR}/softhsm2.cfg
		fi

		PIN=1234
		SOPIN=12345678
		SOFTHSM_TOOLS_DIR=${LICHEE_TOOLS_DIR}/pack/pctools/linux/softhsm
		MODULES=${SOFTHSM_TOOLS_DIR}/lib/softhsm/libsofthsm2.so
		export LD_LIBRARY_PATH=${SOFTHSM_TOOLS_DIR}/lib:${SOFTHSM_TOOLS_DIR}/lib/softhsm:${LIB_LIBRARY_PATH}
		export PATH=${SOFTHSM_TOOLS_DIR}/bin:$PATH
		export SOFTHSM2_CONF=${CFG_KEY_DIR}/softhsm2.cfg

		SOFTHSM_FLAG=1
	fi

	if [ $? -ne 0 ]
	then
		pack_error "dragon toc config file is not exist"
		exit 1
	fi

	rm -f cardscript.fex
	mv cardscript_secure.fex cardscript.fex
	if [ $? -ne 0 ]
	then
		pack_error "dragon cardscript_secure.fex file is not exist"
		exit 1
	fi

	if [ ! -f ${LICHEE_PLAT_OUT}/recovery.img ]; then
		printf "recovery img is not exist, remove recovery cert from dragon_toc.cfg\n"
		sed -i '/recovery/d' dragon_toc.cfg > /dev/null
	else
		local recovery_buf=$(grep "recovery" -nr dragon_toc.cfg)
		if [ x"${recovery_buf}" = x"" ]; then
			readcfg dragon_toc.cfg key_para key > /dev/null
				if [ $? -ne 0 ]; then
					sed -i '/^onlykey=boot/a\onlykey=recovery,      recovery.fex,        SCPFirmwareContentCertPK' dragon_toc.cfg
				else
					sed -i '/^boot=/a recovery=NonTrustedFirmwareContentCertPK' dragon_toc.cfg
					sed -i '/^onlykey=boot/a\onlykey=recovery,     recovery.fex,        recovery.crtpt' dragon_toc.cfg
				fi
		fi
	fi

	if [ "x${PACK_VERITY}" = "x${FLAGS_TRUE}" ]; then
		# verity setup for squashfs type filesystem
		if [ x"${PACK_PLATFORM}" = x"openwrt" ] || [ x"${PACK_PLATFORM}" = x"bsp" ] || [ x"${PACK_PLATFORM}" = x"buildroot" ]; then
			rm -rf rootfs.fex
			local link_real_new=$(get_realpath ${LICHEE_PLAT_OUT} ./)

			if [ x"${PACK_PLATFORM}" = x"openwrt" ]; then
				cp ${link_real_new}/rootfs.img		rootfs.fex
			else
				cp ${link_real_new}/rootfs.squashfs	rootfs.fex
			fi

			if [ "x${PACK_KERN}" == "xlinux-5.4" \
					-o "x${PACK_KERN}" == "xlinux-5.4-ansc" \
					-o "x${PACK_KERN}" == "xlinux-5.10" \
					-o "x${PACK_KERN}" == "xlinux-5.10-origin" \
					-o "x${PACK_KERN}" == "xlinux-5.15" \
					-o "x${PACK_KERN}" == "xlinux-5.15-origin" ]; then

				squashfs_real_size=`hexdump -s 0x28 -n 4 -e '/4 "%d"' rootfs.fex`
				squashfs_data_blocks=`expr \( ${squashfs_real_size} + 4095 \) / 4096`

				local TEMP=${LC_ALL}
				export LC_ALL=C

				veritysetup --data-blocks=${squashfs_data_blocks} format rootfs.fex hash_tree > raw_table

				export LC_ALL=${TEMP}

				readcfg dragon_toc.cfg key_para key > /dev/null
				if [ $? -ne 0 ]; then
					sed -i '/^onlykey=boot/a\onlykey=rootfs,          hash_tree,        SCPFirmwareContentCertPK' dragon_toc.cfg
				else
					sed -i '/^boot=/a rootfs=NonTrustedFirmwareContentCertPK' dragon_toc.cfg
					sed -i '/^onlykey=boot/a\onlykey=rootfs,          hash_tree,        rootfs.crtpt' dragon_toc.cfg
				fi
			else
				# get sample from squashfs rootfs
				local rootfs_per_MB=`grep "^rootfs_per_MB=" env.cfg | awk -F = '{printf $2}'`
				if [ -z $rootfs_per_MB ]; then
					echo "rootfs_per_MB is not defined in env.cfg, use default value 4096"
					rootfs_per_MB=4096
				fi

				extract_squashfs $rootfs_per_MB rootfs.fex rootfs-extract.fex
				if [ $? -ne 0 ]; then
					echo "extract squashfs error"
					exit 1;
				fi

				readcfg dragon_toc.cfg key_para key > /dev/null
				if [ $? -ne 0 ]; then
					sed -i '/^onlykey=boot/a\onlykey=rootfs,          rootfs-extract.fex,        SCPFirmwareContentCertPK' dragon_toc.cfg
				else
					sed -i '/^boot=/a rootfs=NonTrustedFirmwareContentCertPK' dragon_toc.cfg
					sed -i '/^onlykey=boot/a\onlykey=rootfs,          rootfs-extract.fex,        rootfs.crtpt' dragon_toc.cfg
				fi
			fi
		else
			# generate verity data, suport more different filesystem in the future
			(dmverity_genHashTable rootfs.fex rootfsHashTree.fex rootfsHashTable.fex &&
			openssl dgst -sha256 -binary -sign $CFG_KEY_DIR/SCPFirmwareContentCertPK.pem rootfsHashTable.fex > rootfsHashSign.fex &&
			openssl rsa -in $CFG_KEY_DIR/SCPFirmwareContentCertPK.pem -pubout -out rootfsPubKey.pk &&
			dmverity_genDownloadFile rootfs.fex rootfsHashSign.fex rootfsHashTable.fex rootfsHashTree.fex VerityInfo.fex) ||
			{ pack_error "generate verity data failed"; exit 1; }

			# add partition for verity data
			(add_partition -2 rootfsverityInfo 4096 "VerityInfo.fex" &&
			maybe_busybox unix2dos sys_partition.fex &&
			script  sys_partition.fex > /dev/null) ||
			{ pack_error "add verity info part failed"; exit 1; }

			# add verity tools into ramdisk
			local rootfsPath=`readlink -f rootfs.fex`
			local keyPath=`readlink -f rootfsPubKey.pk`
			local blockSize=`dmverity_determ_blk_size ${rootfsPath}`
			dmverity_deal $blockSize rootfsverityInfo ext4 $keyPath ||
			{ pack_error "deal verity utils failed"; exit 1; }
		fi
	fi

	if [ "x${PACK_SIGNFEL}" = "x${FLAGS_TRUE}" ]; then
		do_signature_fel
	fi

	do_signature_ft

	do_signature_toc0

	#readcfg determines whether the cfg file is legacy or new
	readcfg dragon_toc.cfg key_para key > /dev/null
	if [ $? -ne 0 ]; then
		dragonsecboot -toc1 dragon_toc.cfg $CFG_KEY_DIR ${LICHEE_PACK_OUT_DIR}/cnf_base.cnf ${LICHEE_PACK_OUT_DIR}/version_base.mk
		if [ $? -ne 0 ]
		then
			pack_error "dragon toc1 run error"
			exit 1
		fi
		cert=".der"
	else
		do_signature_toc1
		cert=".crtpt"
	fi

	sigbootimg --image boot.fex --cert toc1/cert/boot${cert} --output boot_sig.fex
	if [ $? -ne 0 ] ; then
		pack_error "Pack cert to image error"
		exit 1
	else
		mv -f boot_sig.fex boot.fex
	fi

	do_signature_dsp

	do_signature_riscv

	if [ "x${PACK_VERITY}" = "x${FLAGS_TRUE}" ]; then
		if [ x"${PACK_PLATFORM}" = x"openwrt" ] || [ x"${PACK_PLATFORM}" = x"bsp" ] || [ x"${PACK_PLATFORM}" = x"buildroot" ]; then
			if [ "x${PACK_KERN}" == "xlinux-5.4" \
					-o "x${PACK_KERN}" == "xlinux-5.4-ansc" \
					-o "x${PACK_KERN}" == "xlinux-5.10" \
					-o "x${PACK_KERN}" == "xlinux-5.10-origin" \
					-o "x${PACK_KERN}" == "xlinux-5.15" \
					-o "x${PACK_KERN}" == "xlinux-5.15-origin" ]; then
				verity_root_hash_str=`grep "Root hash:" raw_table | awk '{print $3}'`
				verity_salt_str=`grep "Salt:" raw_table | awk '{print $2}'`

				update_squashfs_verity -f rootfs.fex -c toc1/cert/rootfs${cert} -t hash_tree -r ${verity_root_hash_str} -s ${verity_salt_str}
				if [ $? -ne 0 ]; then
					pack_error "add verity block error."
					exit 1
				fi
			else
				update_squashfs rootfs.fex toc1/cert/rootfs${cert}
				if [ $? -ne 0 ]
				then
					pack_error "signature squashfs rootfs error."
					exit 1
				fi
			fi
		fi
	fi

	local link_real=$(get_realpath ${LICHEE_PLAT_OUT} ./)
	local recovery_path=${link_real}/recovery.img

	if [ -f "$recovery_path" ]; then
		sigbootimg --image recovery.fex --cert toc1/cert/recovery${cert} --output recovery_sig.fex
		if [ $? -ne 0 ] ; then
			pack_error "Pack cert to image error"
			exit 1
		else
			mv -f recovery_sig.fex recovery.fex
		fi
	fi

	echo "secure signature ok!"
}

function do_android_signature()
{
	if [ "x$LINUX_DTBO_FILE" = "x" ]; then
		echo "do not set LINUX_DTBO_FILE"
		line_num=`sed -n -e "/default.dtbo/=" dragon_toc.cfg`
		if [ "x$line_num" != "x" ]; then
			sed -i "$line_num s/^/;/g" dragon_toc.cfg
		fi
	else
		if [ -f $LINUX_DTBO_FILE ]
		then
			sed -i "s/default.dtbo/$LINUX_DTBO_FILE/g" dragon_toc.cfg
		else
			line_num=`sed -n -e "/default.dtbo/=" dragon_toc.cfg`
			if [ "x$line_num" != "x" ]; then
				sed -i "$line_num s/^/;/g" dragon_toc.cfg
			fi
		fi
	fi

	if [ $? -ne 0 ]
	then
		pack_error "dragon toc config file is not exist"
		exit 1
	fi

	rm -f cardscript.fex
	mv cardscript_secure.fex cardscript.fex
	if [ $? -ne 0 ]
	then
		pack_error "dragon cardscript_secure.fex file is not exist"
		exit 1
	fi

	do_signature_ft

	do_signature_toc0

	#readcfg determines whether the cfg file is legacy or new
	readcfg dragon_toc.cfg key_para key > /dev/null
	if [ $? -ne 0 ]; then
		dragonsecboot -toc1 dragon_toc.cfg $CFG_KEY_DIR ${LICHEE_PACK_OUT_DIR}/cnf_base.cnf ${LICHEE_PACK_OUT_DIR}/version_base.mk
		if [ $? -ne 0 ]
		then
			pack_error "dragon toc1 run error"
			exit 1
		fi
		cert=".der"
	else
		do_signature_toc1
		cert=".crtpt"
	fi

	if [ -n "$PACK_MIXED_FIRMWARE" ] && [ -e dboot.fex ]; then
		local keyname=$(awk -F, '/^[[:space:]]*onlykey=boot\S*,[[:space:]]*dboot.fex,/{print $1}' dragon_toc.cfg  | awk -F= '{print $2}')
		sigbootimg --image dboot.fex --cert toc1/cert/${keyname}${cert} --output dboot_sig.fex
		[ $? -ne 0 ] && pack_error "Pack cert to image error" && exit 1
		mv -f dboot_sig.fex dboot.fex
	fi

	echo "secure android signature ok!"
}

################################ Tina func ################################
function get_partition_downfile_size()
{
    local downloadfile_name=`echo $1 | awk -F '=' '{print $2}'`
    if [ x${downloadfile_name: 0-4} != x".fex" ]; then
        pack_error "downloadfile format is wrong, it should be end with .fex"
        exit -1
    fi
    if [ ! -f ${downloadfile_name} ]; then
        echo "  file ${downloadfile_name} not find"
    else
        if [ -L ${downloadfile_name} ]; then
            local downloadfile_name_link=`readlink -f ${downloadfile_name}`
            local linkfile_name=${downloadfile_name_link##*/}
            echo "  ${downloadfile_name} -> ${downloadfile_name_link}"
            if [ ! -f ${downloadfile_name_link} ]; then
                echo "  link file ${linkfile_name} not find"
            else
                local linkfile_size=`ls -lh ${downloadfile_name_link} | awk '{print $5}'`
                echo "  ${linkfile_name} size : ${linkfile_size} byte"
            fi
        else
            local downloadfile_size=`ls -lh ${downloadfile_name} | awk '{print $5}'`
            echo "  ${downloadfile_name} size : ${downloadfile_size} byte"
        fi
    fi
}

function get_partition_mbr_size()
{
    local partition_size_name=`echo $1 | awk -F '=' '{print $1}' | sed 's/partition/mbr/g'`
    local partition_size=`echo $1 | awk -F '=' '{print $2}'`
    echo "  ${partition_size_name}  : ${partition_size} Kbyte"
}

function show_partition_message()
{
    grep -c '[mbr]' $1 > /dev/null
    if [ $? -eq 0 ]; then
        cp $1 ./show_sys_partition.tmp;
        sed -i '/^[\r;]/d' ./show_sys_partition.tmp;
        sed -i '/partition_start/d' ./show_sys_partition.tmp;
        sed -i '/user_type/d' ./show_sys_partition.tmp;
        sed -i 's/\[partition\]/------------------------------------/g' ./show_sys_partition.tmp;
        sed -i 's/[ "\r]//g' ./show_sys_partition.tmp;
        sed -i '/^[;]/d' ./show_sys_partition.tmp;
        sed -i 's/name/partition_name/g' ./show_sys_partition.tmp;
        sed -i 's/size/partition_size/g' ./show_sys_partition.tmp;
        echo "------------------------------------"
        while read line
        do
            if [ "$line" == "------------------------------------" ];then
                echo "$line"
            else
                echo "  $line" | sed 's/=/  : /g'
                echo "  $line" | grep "mbr" >> /dev/null
                if [ $? -eq 0 ]; then
                    read line
                    get_partition_mbr_size $line
                fi
                echo "$line" | grep "downloadfile" >> /dev/null
                if [ $? -eq 0 ]; then
                    get_partition_downfile_size $line
                fi
            fi
        done < ./show_sys_partition.tmp
        echo "------------------------------------"
        rm ./show_sys_partition.tmp
    else
        echo "==========input is not a partition file=========="
    fi
}

function sparse_ext4()
{
    local img=$1
    local sparse_img=$2

    if file $img | grep -q ext4 ;then
        echo "now make sparse ext4 img: $img"
    else
        echo "$img is not ext4 img"
        file $img
        return
    fi

    img2simg $img $sparse_img
}

# pack user resources to a vfat filesystem
# To use this, please add a folder "user-resource" in configs to save files, and add a partition to sys_partition.fex/sys_partition_nor.fex like this:
# [partition]
#   name         = user-res
#   size         = 1024	//size should be 32 aligned
#   downloadfile = "user-resource.fex"
#   user_type    = 0x8000
function make_user_res()
{
    printf "make user resource for : $1\n"
    local USER_RES_SYS_PARTITION=$1
    local USER_RES_PART_NAME=user-res
    local USER_RES_FILE=user-resource

    printf "handle partition ${USER_RES_PART_NAME}\n"
    local USER_RES_PART_DOWNLOAD_FILE=user-resource.fex
    local USER_RES_PART_SIZE=`sed -n "/${USER_RES_PART_NAME}/{N;p}" ${USER_RES_SYS_PARTITION} | awk '$0~"size"{print $3/2}'`
    local USER_RES_FILE_PATH=$CFG_TOP_DIR/${PACK_PLATFORM}/target/$PACK_IC/$PACK_IC-${PACK_BOARD}/configs/${USER_RES_FILE}

    if [ x"${USER_RES_PART_DOWNLOAD_FILE}" != x"" -a  x"${USER_RES_PART_SIZE}" != x"" ]; then
        rm -f ${LICHEE_PACK_OUT_DIR}/user-resource.fex
        mkfs.vfat ${LICHEE_PACK_OUT_DIR}/user-resource.fex -C ${USER_RES_PART_SIZE}
        if [ -d ${USER_RES_FILE_PATH} ]; then
            USER_RES_FILE_SIZE=`du --apparent-size --summarize "${USER_RES_FILE_PATH}" | awk '{print $1}'`
            printf "file size: ${USER_RES_FILE_SIZE}\n"
            printf "partition size: ${USER_RES_PART_SIZE}\n"
            if [ ${USER_RES_PART_SIZE} -le ${USER_RES_FILE_SIZE} ]; then
                printf "file size is larger than partition size, please check your configuration\n"
                printf "please enlarge size of ${USER_RES_PART_NAME} in sys_partition or remove some files in $USER_RES_FILE_PATH\n"
                exit -1
            fi
            mcopy -s -v -i ${LICHEE_PACK_OUT_DIR}/${USER_RES_PART_DOWNLOAD_FILE} ${USER_RES_FILE_PATH}/* ::
            if [ $? -ne 0 ]; then
                printf "mcopy file fail, exit\n"
                exit -1
            fi
        else
            printf "can not find ${USER_RES_FILE_PATH}, ignore it\n"
        fi
    else
        printf "no user resource partitions\n"
    fi
}

#[partition]
#    name         = app
#    size         = 10080
#    downloadfile = "app.fex"
#    user_type    = 0x8000
function make_app_res()
{
    local APP_PART_NAME=app
    cp $1 sys_partition_tmp_app.fex

    sed -i '/^[ \t]*downloadfile/d' sys_partition_tmp_app.fex
    maybe_busybox unix2dos sys_partition_tmp_app.fex
    script  sys_partition_tmp_app.fex > /dev/null
    update_mbr sys_partition_tmp_app.bin 1 sunxi_mbr_tmp_app.fex > /dev/null

    local APP_PART_DOWNLOAD_FILE=app.fex
    local APP_PART_FILE_PATH=$CFG_TOP_DIR/out/$PACK_IC/$PACK_BOARD/$PACK_PLATFORM/build_dir/target/app
    local APP_PART_SIZE_IN_SECTOR=`parser_mbr sunxi_mbr_tmp_app.fex get_size_by_name ${APP_PART_NAME}`
	local TINA_TOOLS_PATH=$CFG_TOP_DIR/out/$PACK_IC/$PACK_BOARD/$PACK_PLATFORM/staging_dir/host/bin

    if [ x${APP_PART_DOWNLOAD_FILE} != x'' -a  x${APP_PART_SIZE_IN_SECTOR} != x'' ]; then
        let APP_PART_SIZE_IN_K=$APP_PART_SIZE_IN_SECTOR/2
        echo "APP_PART_DOWNLOAD_FILE = ${LICHEE_PACK_OUT_DIR}/${APP_PART_DOWNLOAD_FILE}"
        rm -f ${LICHEE_PACK_OUT_DIR}/${APP_PART_DOWNLOAD_FILE}
        ${TINA_TOOLS_PATH}/make_ext4fs -l ${APP_PART_SIZE_IN_K}k -b 1024 -m 0 -j 1024 ${LICHEE_PACK_OUT_DIR}/${APP_PART_DOWNLOAD_FILE}  ${APP_PART_FILE_PATH}
    else
        printf "no app resource partitions\n"
    fi
}

#[partition]
#    name         = data
#    size         = 10080
#    downloadfile = "data.fex"
#    user_type    = 0x8000
function make_data_res()
{
    local DATA_PART_NAME=data
    cp $1 sys_partition_tmp_data.fex

    sed -i '/^[ \t]*downloadfile/d' sys_partition_tmp_data.fex
    maybe_busybox unix2dos sys_partition_tmp_data.fex
    script  sys_partition_tmp_data.fex > /dev/null
    update_mbr sys_partition_tmp_data.bin 1 sunxi_mbr_tmp_data.fex > /dev/null

    local DATA_PART_DOWNLOAD_FILE=data.fex
    local DATA_PART_DOWNLOAD_FILE_SPARSE=data_s.fex
    local DATA_PART_FILE_PATH=$CFG_TOP_DIR/out/$PACK_IC/$PACK_BOARD/$PACK_PLATFORM/build_dir/target/data
    local DATA_PART_SIZE_IN_SECTOR=`parser_mbr sunxi_mbr_tmp_data.fex get_size_by_name ${DATA_PART_NAME}`
	local TINA_TOOLS_PATH=$CFG_TOP_DIR/out/$PACK_IC/$PACK_BOARD/$PACK_PLATFORM/staging_dir/host/bin

    if [ x${DATA_PART_DOWNLOAD_FILE} != x'' -a  x${DATA_PART_SIZE_IN_SECTOR} != x'0' ]; then
        let DATA_PART_SIZE_IN_K=$DATA_PART_SIZE_IN_SECTOR/2
        echo "DATA_PART_DOWNLOAD_FILE = ${LICHEE_PACK_OUT_DIR}/${DATA_PART_DOWNLOAD_FILE}"
        rm -f ${LICHEE_PACK_OUT_DIR}/${DATA_PART_DOWNLOAD_FILE}
        rm -f ${LICHEE_PACK_OUT_DIR}/${DATA_PART_DOWNLOAD_FILE_SPARSE}
        ${TINA_TOOLS_PATH}/make_ext4fs -l ${DATA_PART_SIZE_IN_K}k -b 1024 -m 0 -j 1024 ${LICHEE_PACK_OUT_DIR}/${DATA_PART_DOWNLOAD_FILE}  ${DATA_PART_FILE_PATH}
        sparse_ext4 ${LICHEE_PACK_OUT_DIR}/${DATA_PART_DOWNLOAD_FILE} ${LICHEE_PACK_OUT_DIR}/${DATA_PART_DOWNLOAD_FILE_SPARSE}
    else
        printf "no data resource partitions\n"
    fi
}

################################ Platform func ################################
function do_pack_android()
{
	local localpath=$(readlink -f $(pwd))
	local androidout=$(readlink -f ${ANDROID_IMAGE_OUT})
	local link_real=$(get_realpath $androidout $localpath)

	printf "packing for android\n"

	if [ -z "${ANDROID_IMAGE_OUT}" ] ; then
		pack_error "please specify ANDROID_IMAGE_OUT env"
		exit 1
	fi

	local fex_list=($(\gawk '$0~"^[[:space:]]*downloadfile[[:space:]]*="{print $NF}' sys_partition.fex | sed 's/[",\r,\n]//g'))
	fex_list+=(vendor_boot-debug.fex)

	local img_name=""
	for fex_name in ${fex_list[@]}; do
		img_name=${fex_name%\.fex}.img
		if [ -f ${ANDROID_IMAGE_OUT}/${img_name} ]; then
			ln -sf ${link_real}/${img_name} ${fex_name}
			echo "link ${img_name} -> ${fex_name}"
		fi
	done

	if [ -e $androidout/vmlinux ]; then
		export PATH=$PATH:${LICHEE_TOP_DIR}/build/bin
		local vmlinuxpath=$(dirname $(readlink -f $androidout/vmlinux))
		local vmlinuxname=$(basename $(readlink -f $androidout/vmlinux))
		(cd $vmlinuxpath && tar cf $localpath/vmlinux.tar.bz2 --use-compress-prog=lbzip2 $vmlinuxname)
		rm -rf vmlinux.fex
		ln -sf vmlinux.tar.bz2 vmlinux.fex
	fi

	if [ "x${PACK_SECURE}" = "xsecure" ]; then
		echo "secure"
		do_android_signature
	else
		echo "normal"
	fi
}

function prepare_mixed_androiddragonboard()
{
	local mixed_fw_type

	if [ "${PACK_TYPE}" != "android" ] || [ -z "$PACK_MIXED_FIRMWARE" ]; then
		return 0
	fi

	case "$PACK_MIXED_FIRMWARE" in
		dragonboard|dragonabts)
			mixed_fw_type="$PACK_MIXED_FIRMWARE"
			pack_info "${FUNCNAME[0]}: mixed firmware type: $mixed_fw_type"
			;;
		*)
			echo "Unsupport mixed firmware type: $PACK_MIXED_FIRMWARE"
			return 1
	esac

	(
		cd ${LICHEE_PACK_OUT_DIR}

		local localpath=$(readlink -f $(pwd))
		local mixedboardout=$(readlink -f ${CFG_PLAT_OUT}/../$mixed_fw_type)
		if [ ! -d $mixedboardout ]; then
			pack_error "${FUNCNAME[0]}: cannot find out path for $mixed_fw_type"
			exit 1
		fi

		local envpath=($LICHEE_BOARD_CONFIG_DIR/$mixed_fw_type $LICHEE_CHIP_CONFIG_DIR/configs/default)
		local partition=(bootloader_b:boot-resource.fex env_b:denv.fex
					boot_b:dboot.fex vendor_boot_b:vendor_boot.fex media_data)

		local item name linenum nstart nend nmax file

		for item in ${partition[@]}; do
			name=${item/:*}
			linenum=$(sed -n "/^\s*name\s*=\s*$name/=" sys_partition.fex)
			if [ -z "$linenum" ]; then
				pack_error "${FUNCNAME[@]}: leak neccery partition $name in sys_partition.fex"
				exit 1
			fi
		done

		for item in ${envpath[@]}; do
			if [ -e $item/env.cfg ]; then
				cp $item/env.cfg denv.cfg
				sed -i '/^\s*boot_normal=/s/\<boot\>/boot_b/g' denv.cfg
				generate_env_for_uboot denv.cfg $mixedboardout/env.img
				rm -rf denv.cfg
				break
			fi
		done

		if  [ ! -e $mixedboardout/env.img  ] || \
			[ ! -e $mixedboardout/boot.img ] || \
			[ ! -e $mixedboardout/rootfs.ext4 ] || \
			[ ! -e $LICHEE_BOARD_CONFIG_DIR/$mixed_fw_type/test_config.fex ]; then
			pack_error "${FUNCNAME[@]}: leak neccery img/fex for $mixed_fw_type"
			exit 1
		fi

		printf "prepare for mixed android/$mixed_fw_type packing...\n"
		cp -vf sys_partition.fex sys_partition_orig.fex
		cp -vf dragon_toc.cfg    dragon_toc_orig.cfg
		for item in ${partition[@]}; do
			name=${item/:*}
			linenum=$(sed -n "/^\s*name\s*=\s*$name/=" sys_partition.fex)
			nstart=$linenum
			nend=$linenum
			nmax=$(wc -l sys_partition.fex | awk '{print $1}')
			while [ $nstart -gt 1 ]; do
				nstart=$((nstart-1))
				if [ -n "$(sed -n "$nstart p" sys_partition.fex | grep "^\s*\[\S\+\]")" ]; then
					break;
				fi
			done

			while [ $nend -lt $nmax ]; do
				nend=$((nend+1))
				if [ -n "$(sed -n "$nend p" sys_partition.fex | grep "^\s*\[\S\+\]")" ]; then
					break;
				fi
			done
			[ $nend -ne $nmax ] && nend=$((nend-1))

			file="$(sed -n "${nstart},${nend}p" sys_partition.fex | \
					awk -F= '/^[[:space:]]*downloadfile[[:space:]]*=/{print $2}')"
			dlfile=${e#*:}
			case $name in
				bootloader_b|env_b|boot_b|vendor_boot_b)
					if [ -z "$file" ]; then
						sed -i "$linenum a\ \ \ \ downloadfile = \"${item#*:}\"" sys_partition.fex
					fi
					;;
				media_data)
					local cmd="$nstart i"
					local size=$(stat $mixedboardout/rootfs.ext4 --format="%s")

					size=$(((size+32*1024*1024-1)/(16*1024*1024)*16))  # at least size + 16M, and 16M align

					if [ -z "$(grep "^\s*name\s*=\s*rootfs" sys_partition.fex)" ]; then
						cmd+="[partition]\n"
						cmd+="    name         = rootfs\n"
						cmd+="    size         = ${size}M\n"
						cmd+="    downloadfile = \"drootfs.fex\"\n"
						cmd+="    user_type    = 0x8000\n"
						cmd+="\n"
					fi
					[ "$cmd" != "$nstart i" ] && sed -i "$cmd" sys_partition.fex
					;;
			esac
		done

		# Delete "^M" under Windows
		sed -i 's|||g' sys_partition.fex

		readcfg dragon_toc.cfg key_para key > /dev/null
		if [ $? -ne 0 ]; then
			[ -z "$(grep "^\s*onlykey=boot_b,\s*dboot.fex," dragon_toc.cfg)" ] && \
			sed -i 's|^\(\s*onlykey=boot_b,\s*\)\S*,|\1dboot.fex,|g'    dragon_toc.cfg

			[ -z "$(grep "^\s*onlykey=boot_b,\s*dboot.fex," dragon_toc.cfg)" ] && \
			echo "onlykey=boot_b,dboot.fex,SCPFirmwareContentCertPK" >> dragon_toc.cfg
		else
			if [ -z "$(grep "^\s*onlykey=boot_b,\s*dboot.fex," dragon_toc.cfg)" ]; then
				sed -i '/^optee=/a boot_b=SCPFirmwareContentCertPK' dragon_toc.cfg
				sed -i '/^item=optee/a\onlykey=boot_b,dboot.fex,boot_b.crtpt' dragon_toc.cfg
			fi
		fi

		cp $LICHEE_BOARD_CONFIG_DIR/$mixed_fw_type/test_config.fex .
		maybe_busybox dos2unix test_config.fex
		cp test_config.fex boot-resource/
		script test_config.fex > /dev/null
		cp test_config.bin boot-resource/

		cp $mixedboardout/env.img denv.fex
		cp $mixedboardout/boot.img dboot.fex
		cp $mixedboardout/rootfs.ext4 drootfs.fex
		echo "android:$PACK_MIXED_FIRMWARE" > mixed-image-type.txt
		cp -vf sys_partition.fex sys_partition_mixed.fex
		cp -vf dragon_toc.cfg    dragon_toc_mixed.cfg
	)
	if [ $? -ne 0 ]; then
		pack_error "${FUNCNAME[0]} fail"
		return 1
	fi
	return 0
}

function do_pack_dragonboard()
{
	local link_real=$(get_realpath ${LICHEE_PLAT_OUT} ./)
	printf "packing for dragonboard\n"

	ln -sf ${link_real}/boot.img boot.fex
	ln -sf ${link_real}/rootfs.ext4 rootfs.fex
	ln -sf ${link_real}/rootfs.ubifs rootfs-ubifs.fex

	if [ "x${PACK_SECURE}" = "xsecure" ]; then
		do_signature
	else
		echo "normal"
	fi
}

function do_pack_dragonabts()
{
	local link_real=$(get_realpath ${LICHEE_PLAT_OUT} ./)
	printf "packing for dragonabts\n"

	ln -sf ${link_real}/boot.img boot.fex
	ln -sf ${link_real}/rootfs.ext4 rootfs.fex
	ln -sf ${link_real}/rootfs.ubifs rootfs-ubifs.fex

	if [ "x${PACK_SECURE}" = "xsecure" ]; then
		do_signature
	else
		echo "normal"
	fi
}

function do_pack_linux()
{
	local link_real=$(get_realpath ${LICHEE_PLAT_OUT} ./)
	local recovery_path=${link_real}/recovery.img

	printf "packing for linux\n"

	do_fit_image
	if [ $? -eq 0 ]; then
		[ -f kernel.itb ] && mv kernel.itb   kernel.fex
		[ -f kernel-dtb.itb ] && mv kernel-dtb.itb   kernel-dtb.fex
	else
		[ -f ${link_real}/bootB.img ] && ln -sf ${link_real}/bootB.img bootB.fex
		ln -sf ${link_real}/boot.img        boot.fex

		# Those files is ready for SPINor.
		ln -sf ${link_real}/uImage          kernel.fex
		if [ x"${PACK_PLATFORM}" = x"openwrt" ]; then
			ln -sf ${link_real}/rootfs.img rootfs_nor.fex
		else
			ln -sf ${link_real}/rootfs.squashfs rootfs_nor.fex
		fi
	fi

	if [ x"${PACK_PLATFORM}" = x"openwrt" ]; then
		ln -sf ${link_real}/rootfs.img     rootfs.fex
	else
		ln -sf ${link_real}/rootfs.ext4     rootfs.fex
	fi

	ln -sf ${link_real}/rootfs.ubifs     rootfs-ubifs.fex

	if [ x"${LICHEE_PACK_NOR_AND_DEFAULT_FLASH}" != x"" ]; then
		if [ x"${PACK_NOR}" = x"default" ]; then
			echo "ln boot.default and rootfs.default"
			ln -sf ${link_real}/boot.default boot.fex
			ln -sf ${link_real}/rootfs.default rootfs.fex
		fi
	fi

	if [ -f "$recovery_path" ]; then
		ln -sf ${recovery_path}     recovery.fex
	fi

	if [ x"${LICHEE_UPDATE_BOOTIMG}" == x"y" ]; then
		rm -rf boot.fex
		rm -rf bootB.fex
		cp ${link_real}/boot.img boot.fex
		#update checksum to boot.img head id[7]
		update_bootimg boot.fex

		if [ -f ${link_real}/bootB.img ]; then
			cp ${link_real}/bootB.img bootB.fex
			update_bootimg bootB.fex
		fi
	fi

	if [ "x${PACK_SECURE}" = "xsecure" ]; then
		echo "secure"
		do_signature
	else
		echo "normal"
	fi
}

function create_kernel_fit_image()
{
	local its_name=$1

	printf "create_kernel_fit_image\n"

	if [ ! -f ${LICHEE_PACK_OUT_DIR}/${its_name}.its ]; then
		printf "can not found ${its_name}.its\n"
		return 1
	fi

	mkimage -f ${its_name}.its ${its_name}.itb
	if [ $? -ne 0 ]; then
		pack_error "mkimage ${its_name}.itb error\n"
		exit 1
	fi
}

function do_fit_image()
{
	printf "do_fit_image\n"

	create_kernel_fit_image kernel
	if [ $? -ne 0 ]; then
		return 1
	fi

	create_kernel_fit_image kernel-dtb
	if [ $? -ne 0 ]; then
		return 1
	fi
}

function main()
{
	local output_resources=${FLAGS_output_resources:-false}
	local from_resources=${FLAGS_from_resources}

	local support_secure_type
	case x$LICHEE_PACK_SECURE_TYPE in
		xnone|xsecure|xany)
			support_secure_type=$LICHEE_PACK_SECURE_TYPE
			;;
		x)
			support_secure_type=any
			;;
		*)
			pack_error "Unsupport pack secure type: $LICHEE_PACK_SECURE_TYPE"
			return 1
			;;
	esac

	if [ "$support_secure_type" != "any" ] && [ "$support_secure_type" != "$PACK_SECURE" ]; then
		pack_error "This platform only support secure type [$support_secure_type], but current using [$PACK_SECURE], please check!!!"
		pack_error "Now, we try using secure type [$support_secure_type]!!!"
		PACK_SECURE=$support_secure_type
	fi

	if [ "$output_resources" == "false" ] && [ -z "$from_resources" ]; then
		do_prepare
		do_ini_to_dts
		do_common
		do_pack_${PACK_TYPE}
		do_finish
		return $?
	fi

	if [ "$output_resources" == "true" ]; then
		do_prepare
		do_ini_to_dts
	elif [ -n "$from_resources" ]; then
		if [ ! -d $from_resources ]; then
			pack_error "Cannot find resources path: $from_resources"
			return 1
		fi

		local count=0
		while [ -e ${LICHEE_PACK_OUT_DIR} -a  $count -lt 20 ]; do
			rm -rf ${LICHEE_PACK_OUT_DIR}
			count=$((count+1))
		done
		cp -rax $from_resources ${LICHEE_PACK_OUT_DIR}
		(
			cd $LICHEE_OUT_DIR
			if [ "${LICHEE_PACK_OUT_DIR}" != "$LICHEE_OUT_DIR/pack_out" ]; then
				rm -rf pack_out
				ln -sf ${LICHEE_IC}/${LICHEE_BOARD}/pack_out pack_out
			fi
		)

		if [ "${PACK_PLATFORM}" == "android" ]; then
			if [ -n "$PACK_MIXED_FIRMWARE" ]; then
				if [ ! -f ${LICHEE_PACK_OUT_DIR}/mixed-image-type.txt ]; then
					pack_error "mixed firmware type [$mixed_fw_type] but resource not mixed type"
					exit 1
				fi

				local resource_type="$(cat ${LICHEE_PACK_OUT_DIR}/mixed-image-type.txt)"
				local mixed_fw_type="android:$PACK_MIXED_FIRMWARE"
				if [ "$resource_type" != "android:$PACK_MIXED_FIRMWARE" ]; then
					pack_error "mixed firmware type [$mixed_fw_type] but resource type [$resource_type]"
					exit 1
				fi
				pack_info "mixed firmware type [$mixed_fw_type]"
				cp -vf ${LICHEE_PACK_OUT_DIR}/sys_partition_mixed.fex ${LICHEE_PACK_OUT_DIR}/sys_partition.fex
				cp -vf ${LICHEE_PACK_OUT_DIR}/dragon_toc_mixed.cfg    ${LICHEE_PACK_OUT_DIR}/dragon_toc.cfg
			else
				if [ -f ${LICHEE_PACK_OUT_DIR}/mixed-image-type.txt ]; then
					pack_info "mixed resource and current is not mixed pack, restore essential files"
					cp -vf ${LICHEE_PACK_OUT_DIR}/sys_partition_orig.fex ${LICHEE_PACK_OUT_DIR}/sys_partition.fex
					cp -vf ${LICHEE_PACK_OUT_DIR}/dragon_toc_orig.cfg    ${LICHEE_PACK_OUT_DIR}/dragon_toc.cfg
					rm -rf ${LICHEE_PACK_OUT_DIR}/boot-resource/test_config.*
				fi
			fi
			partition_size_handle
		fi

		cd ${LICHEE_PACK_OUT_DIR}
		do_common
		do_pack_${PACK_TYPE}
		do_finish
	fi
	return $?
}

main "$@"
